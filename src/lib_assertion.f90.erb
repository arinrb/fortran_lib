<%
  require 'fort'

  INT_KINDS = [8, 16, 32, 64]
  INT_KIND_PAIRS = INT_KINDS.product(INT_KINDS)
  REAL_KINDS = [32, 64,128]
  REAL_KIND_PAIRS = REAL_KINDS.product(REAL_KINDS)
  DIMS = (0..7).to_a
  DIM_PAIRS = DIMS.product(DIMS).select{|d1, d2| d1 == 0 or d2 == 0 or d1 == d2}

  def dim_paris_kind_pairs_to_types(dim_pairs, kind_pairs, type)
    dim_pairs.product(kind_pairs).map{|dims, kinds|
      dims.zip(kinds).map{|dim, kind|
        type.new(dim, kind)}}
  end

  TYPE_PAIRS\
  = dim_paris_kind_pairs_to_types(DIM_PAIRS, INT_KIND_PAIRS, ::Fort::Type::IntegerType)\
  + dim_paris_kind_pairs_to_types(DIM_PAIRS, REAL_KIND_PAIRS, ::Fort::Type::RealType)\
  + dim_paris_kind_pairs_to_types(DIM_PAIRS, REAL_KIND_PAIRS, ::Fort::Type::ComplexType)\
  + DIM_PAIRS.map{|dims| dims.map{|dim| ::Fort::Type::CharacterType.new(dim, '*')}}\
  + DIM_PAIRS.map{|dims| dims.map{|dim| ::Fort::Type::LogicalType.new(dim)}}

  LOGICAL_TYPES = DIMS.map{|dim| ::Fort::Type::LogicalType.new(dim)}

  OPS = [{op: '.not.all', suf: '', msg: '/='}, {op: 'all', suf: '_not', msg: '=='}]
%>

#include "utils.h"
module lib_assertion
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  use, intrinsic:: iso_fortran_env, only: ERROR_UNIT
  use lib_comparable, only: equivalent
  use lib_character, only: s, operator(+)
  use lib_io, only: new_unit, tempfile, close_tempfile

  implicit none

  private
  <%- OPS.each{|op| -%>
    public:: assert<%= op[:suf] %>_equal
  <%- } -%>
  public:: assert_true
  public:: assert_false

  <%- OPS.each{|op| -%>
    interface assert<%= op[:suf] %>_equal
      <%- TYPE_PAIRS.each{|t1, t2| -%>
        module procedure assert<%= op[:suf] %>_equal<%= t1 %><%= t2 %>
      <%- } -%>
    end interface assert<%= op[:suf] %>_equal
  <%- } -%>

  <%- LOGICAL_TYPES.each{|t| -%>
    interface assert_true
      module procedure assert_true<%= t %>
    end interface assert_true

    interface assert_false
      module procedure assert_false<%= t %>
    end interface assert_false
  <%- } -%>

contains

  !  iIrRzZcl
  ! i**------
  ! I**------
  ! r--**----
  ! R--**----
  ! z----**--
  ! Z----**--
  ! c------*-
  ! l-------*
  ! total 14 combinations in types.
  !
  !  01234567
  ! 0********
  ! 1**------
  ! 2*-*-----
  ! 3*--*----
  ! 4*---*---
  ! 5*----*--
  ! 6*-----*-
  ! 7*------*
  ! total 22 combinations in dimensions.
  ! total 308 combinations in type*dimension.
  <%- TYPE_PAIRS.each{|t1, t2| -%>
    <%- OPS.each{|op| -%>
      subroutine assert<%= op[:suf] %>_equal<%= t1 %><%= t2 %>(a, b)
        <%= t1.declare %>, intent(in):: a
        <%= t2.declare %>, intent(in):: b

        integer:: ioUA, ioUB
        character(len = 1024):: fileA, fileB

        <%- unless t1.dim == 0 || t2.dim == 0 -%>
          RAISE_IF(any(shape(a) /= shape(b)), shape(a), shape(b))
        <%- end -%>

        if(<%= op[:op] %>((/equivalent(a, b)/)))then
          write(ERROR_UNIT, *) 'a <%= op[:msg] %> b:'
          call tempfile(ioUA, fileA)
          write(ioUA, *) a
          call tempfile(ioUB, fileB)
          write(ioUB, *) b
          call execute_command_line("diff -w -B " + s(fileA) + ' ' + s(fileB) + ' | more')
          call close_tempfile(ioUA)
          call close_tempfile(ioUB)
          RAISE()
        end if
      end subroutine assert<%= op[:suf] %>_equal<%= t1 %><%= t2 %>
    <%- } -%>
  <%- } -%>

  <%- LOGICAL_TYPES.each{|t| -%>
    subroutine assert_true<%= t %>(mask)
      <%= t.declare %>, intent(in):: mask

      RAISE_IF(.not.all((/mask/)))
    end subroutine assert_true<%= t %>

    subroutine assert_false<%= t %>(mask)
      <%= t.declare %>, intent(in):: mask

      RAISE_IF(any((/mask/)))
    end subroutine assert_false<%= t %>
  <%- } -%>
end module lib_assertion
