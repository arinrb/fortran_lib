<%
  class Type
    require 'ruby_patch'

    SYM_TO_TYPE = {
      i: 'integer',
      I: 'integer(8)',
      r: 'real',
      R: 'double precision',
      z: 'complex',
      Z: 'complex(kind(0.0d0))',
      c: 'character(len = *)',
      l: 'logical',
    }

    attr_reader :type, :suf, :dim

    def initialize(sym, dim)
      @type = SYM_TO_TYPE[sym]
      @dim = dim
      @suf = '_' + @type.gsub(/(\W)/, '') + "_#{dim}"
    end

    def parenthesis
      @parenthesis ||= self.class.parenthesis(@dim)
    end

    def self.parenthesis(dim)
      if dim >= 1
        ([':']*dim).join(', ').quote('(', ')')
      else
        ''
      end
    end
  end

  type_pairs = [:i, :I].product([:i, :I])\
  + [:r, :R].product([:r, :R])\
  + [:z, :Z].product([:z, :Z])\
  + [[:c, :c], [:l, :l]]
  dim_pairs = (0..7).to_a.product((0..7).to_a).select{|i, j| i == 0 || j == 0 || i == j}

  PAIRS = type_pairs.product(dim_pairs).map{|type, dim|
    [Type.new(type[0], dim[0]), Type.new(type[1], dim[1])]
  }

  OPS = [{op: '.not.all', suf: '', msg: '/='}, {op: 'all', suf: '_not', msg: '=='}]
%>

module lib_assertion
  use, intrinsic:: iso_fortran_env, only: ERROR_UNIT
  use lib_util, only: raise
  use lib_comparable, only: equivalent
  use lib_character, only: s
  use lib_io, only: new_unit, tempfile, close_tempfile

  implicit none

  private
  <% OPS.each{|op| %>
    public:: assert<%= op[:suf] %>_equal
  <% } %>
  public:: assert_true
  public:: assert_false

  <% PAIRS.each{|t1, t2| %>
    <% OPS.each{|op| %>
      interface assert<%= op[:suf] %>_equal
        module procedure assert<%= op[:suf] %>_equal<%= t1.suf %><%= t2.suf %>
      end interface assert<%= op[:suf] %>_equal
    <% } %>
  <% } %>

  <% (0..7).each{|dim| %>
    interface assert_true
      module procedure assert_true_<%= dim %>
    end interface assert_true

    interface assert_false
      module procedure assert_true_<%= dim %>
    end interface assert_false
  <% } %>

contains

  !  iIrRzZcl
  ! i**------
  ! I**------
  ! r--**----
  ! R--**----
  ! z----**--
  ! Z----**--
  ! c------*-
  ! l-------*
  ! total 14 combinations in types.
  !
  !  01234567
  ! 0********
  ! 1**------
  ! 2*-*-----
  ! 3*--*----
  ! 4*---*---
  ! 5*----*--
  ! 6*-----*-
  ! 7*------*
  ! total 22 combinations in dimensions.
  ! total 308 combinations in type*dimension.
  <% PAIRS.each{|t1, t2| %>
    <% OPS.each{|op| %>
      subroutine assert<%= op[:suf] %>_equal<%= t1.suf %><%= t2.suf %>(a, b)
        <%= t1.type %>, intent(in):: a<%= t1.parenthesis %>
        <%= t2.type %>, intent(in):: b<%= t2.parenthesis %>

        integer:: ioUA, ioUB
        character(len = 1024):: fileA, fileB

        <% unless t1.dim == 0 || t2.dim == 0 %>
          if(all(shape(a) /= shape(b)))then
            write(ERROR_UNIT, *) "shape(a) /= shape(b): ", shape(a), ' /= ', shape(b)
            call raise(__FILE__, __LINE__)
          end if
        <% end %>

        if(<%= op[:op] %>((/equivalent(a, b)/)))then
          write(ERROR_UNIT, *) 'a <%= op[:msg] %> b:'
          call tempfile(ioUA, fileA)
          write(ioUA, *) a
          call tempfile(ioUB, fileB)
          write(ioUB, *) b
          call execute_command_line("diff -w -B " // s(fileA) // ' ' // s(fileB) // ' | more')
          call close_tempfile(ioUA)
          call close_tempfile(ioUB)
          call raise(__FILE__, __LINE__)
        end if
      end subroutine assert<%= op[:suf] %>_equal<%= t1.suf %><%= t2.suf %>
    <% } %>
  <% } %>

  <% (0..7).each{|dim| %>
    subroutine assert_true_<%= dim %>(mask)
      logical, intent(in):: mask<%= Type.parenthesis(dim) %>

      if(.not.all((/mask/)))then
        call raise(__FILE__, __LINE__)
      end if
    end subroutine assert_true_<%= dim %>

    subroutine assert_false_<%= dim %>(mask)
      logical, intent(in):: mask<%= Type.parenthesis(dim) %>

      if(any((/mask/)))then
        call raise(__FILE__, __LINE__)
      end if
    end subroutine assert_false_<%= dim %>
  <% } %>
end module lib_assertion
