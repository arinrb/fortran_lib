<%
  require 'fort'

  INT_TYPES = ::Fort::Type::Integer.multi_provide(dim: 0)
  TYPES\
  = ::Fort::Type::Logical.multi_provide(dim: 0)\
  + ::Fort::Type::Real.multi_provide(dim: 0)\
  + ::Fort::Type::Complex.multi_provide(dim: 0)\
  + ::Fort::Type::Character.multi_provide\
  + INT_TYPES
%>
module character_lib
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>

   implicit none

   private

   public:: s                    ! Same as String#strip method in Ruby.
   public:: operator(+)          ! Syntax sugar of `//'. This will be useful if you want to use `//' within macro where `//' is discarded.
   public:: str ! Convert a value to a string. The result is not stripped.

   integer, parameter, public:: MAX_STR_LEN = 2**11  ! Maximum length of str.

   interface operator(+)
      module procedure add
   end interface operator(+)

   <%- TYPES.each{|t| -%>
      interface str
         module procedure str<%= t %>
      end interface str
   <%- } -%>

contains

   pure function s(str) result(answer)
      character(len = *), intent(in):: str
      character(len = len_trim(adjustl(str))):: answer

      answer = trim(adjustl(str))
   end function s

   elemental function add(str1, str2) result(answer)
      character(len = *), intent(in):: str1, str2
      character(len = len(str1) + len(str2)):: answer

      answer = str1 // str2
   end function add

   <%- TYPES.each{|t| -%>
      pure function str<%= t %>(x) result(ret)
         <%= t.declare %>, intent(in):: x
         character(len=len_trim(adjustl(str_fixed<%= t %>(x)))):: ret

         ret = s(str_fixed<%= t %>(x))
      end function str<%= t %>

      pure function str_fixed<%= t %>(x) result(ret)
         character(len=MAX_STR_LEN):: ret
         <%= t.declare %>, intent(in):: x

         write(ret, *) x
         ret = s(ret)
      end function str_fixed<%= t %>
   <%- } -%>
end module character_lib
