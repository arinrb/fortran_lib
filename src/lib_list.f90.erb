<%
  require 'ruby_patch'
  require 'fort'

  # # Edit here and USERS_MODULES_AND_TYPES bellow to add type(SomeData).
  # # type(SomeData) should have assignment(=).
  # class ::Fort::Type::SomeDataType < ::Fort::Type
  #   require 'ruby_patch'
  #   extend ::RubyPatch::AutoLoad
  #
  #   def initialize(dim = 0)
  #     super
  #   end
  #
  #   def to_s
  #     super
  #   end
  #
  #   def declare
  #     "#{@stem}#{super}"
  #   end
  # end

  ::Fort::Type.class_eval{
    def list_type
      "#{self.to_s}List"
    end

    def list_node_type
      "#{self.to_s}ListNode"
    end
  }
  INTRINSIC_TYPES\
  = [::Fort::Type::LogicalType.new]\
  + (0..13).to_a.map{|i| 2**i}.map{|len| ::Fort::Type::CharacterType.new(0, len)}\
  + [8, 16, 32, 64].map{|kind| ::Fort::Type::IntegerType.new(0, kind)}\
  + [32, 64, 128].map{|kind| ::Fort::Type::RealType.new(0, kind)}\
  + [32, 64, 128].map{|kind| ::Fort::Type::ComplexType.new(0, kind)}

  USERS_MODULES_AND_TYPES = {
    # # You should also edit here to add type(SomeData)
    # lib_some_data: [::Fort::Type::SomeDataType]{|klass| klass.new(0)}
  }
  USER_DEFINED_TYPES = USERS_MODULES_AND_TYPES.values.flatten

  TYPES = INTRINSIC_TYPES + USER_DEFINED_TYPES
%>

#include "utils.h"
module lib_list
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  <%- USERS_MODULES_AND_TYPES.each{|m, t| -%>
    use <%= m %>, non_intrinsic, only: <%= (["assignment(=)"] + t).join(', ') %>
  <%- } -%>

  implicit none

  private

  public:: new       ! Create a size 1 list.
  public:: size      ! Size of a list.
  public:: delete_at ! Delete the N-th node and return a value of the node.
  public:: insert_at ! Insert a node to N-th position.
  ! list: -(1)-(2)-(3)-(4)-
  !    N: 1   2   3   4   5
  public:: val_at              ! Value at N-th node.
  public:: operator(.val.)     ! Same to val_at.
  public:: node_at             ! N-th node.
  ! WARNING: Returns pointer!
  ! BAD: targetNode =  node_at(list, pos)
  ! OK:  targetNode => node_at(list, pos)
  public:: shift ! Delete the head node and return a value of the node.
  public:: unshift              ! Insert a node to the head.
  public:: push    ! Insert a node to the tail.
  public:: pop  ! Delete the tail node and return a value of the node.
  public:: clear                ! Delete all nodes.
  public:: swap                 ! Swap nodes in a list.
  public:: array_from_list      ! List to array convertor.
  public:: copy                 ! Cleate a deep copy of a list.
  public:: assignment(=)        ! List to array, array to list, deep copy of list.
  public:: is_size_one          ! .true. if size of list is one.
  public:: is_empty             ! .true. if size of list is zero.

  <%- TYPES.each{|t| -%>
    public:: <%= t.list_type %>
  <%- } -%>

  <%- TYPES.each{|t| -%>
    type <%= t.list_node_type %>
      <%= t.declare %>:: val
      type(<%= t.list_node_type %>), pointer:: prev => null()
      type(<%= t.list_node_type %>), pointer:: next => null()
    end type <%= t.list_node_type %>

    type <%= t.list_type %>
      type(<%= t.list_node_type %>), pointer:: entry => null()
    end type <%= t.list_type %>
  <%- } -%>

  <%- TYPES.each{|t| -%>
    interface new
      module procedure new<%= t %>
    end interface

    interface size
      module procedure size<%= t %>
    end interface

    interface delete_at
      module procedure delete_at<%= t %>
    end interface

    interface insert_at
      module procedure insert_at<%= t %>
    end interface

    interface val_at
      module procedure val_at<%= t %>
    end interface

    interface operator(.val.)
      module procedure val_at<%= t %>
    end interface

    interface node_at
      module procedure node_at<%= t %>
    end interface

    interface shift
      module procedure shift<%= t %>
    end interface

    interface unshift
      module procedure unshift<%= t %>
    end interface

    interface push
      module procedure push<%= t %>
    end interface

    interface pop
      module procedure pop<%= t %>

    end interface

    interface clear
      module procedure clear<%= t %>
    end interface

    interface swap
      module procedure swap<%= t %>
    end interface

    interface array_from_list
      module procedure array_from_list<%= t %>
    end interface

    interface copy
      module procedure copy<%= t %>
    end interface

    interface assignment(=)
      module procedure copy<%= t %>
      module procedure list_from_array_coercion<%= t %>
      module procedure array_from_list_coercion<%= t %>
    end interface

    interface is_size_one
      module procedure is_size_one<%= t %>
    end interface

    interface is_empty
      module procedure is_empty<%= t %>
    end interface
  <%- } -%>

contains

  <%- TYPES.each{|t| -%>
    subroutine swap<%= t %>(list, pos1, pos2)
      type(<%= t.list_type %>), intent(inout):: list
      integer, intent(in):: pos1, pos2

      type(<%= t.list_node_type %>), pointer:: posLNodePrev, posLNode, posLNodeNext
      type(<%= t.list_node_type %>), pointer:: posRNodePrev, posRNode, posRNodeNext
      integer:: posL, posR, nList

      posL = min(pos1, pos2)
      posR = max(pos1, pos2)
      nList = size(list)
      RAISE_IF(posL < 1 .or. nList < posR, 'Out of range: posL, posR = ', posL, posR)
      if(posL == posR) return

      posLNode => node_at(list, posL)
      posLNodePrev => posLNode%prev
      posRNode => node_at(list, posR)
      posRNodeNext => posRNode%next
      if(posR - posL == 1)then
        if(associated(posLNodePrev)) posLNodePrev%next => posRNode
        posLNode%next => posRNodeNext
        posRNode%next => posLNode
        if(associated(posRNodeNext)) posRNodeNext%prev => posLNode
        posRNode%prev => posLNodePrev
        posLNode%prev => posRNode
      else
        posLNodeNext => posLNode%next
        posRNodePrev => posRNode%prev

        if(associated(posLNodePrev)) posLNodePrev%next => posRNode
        posLNode%next => posRNodeNext
        posRNodePrev%next => posLNode
        posRNode%next => posLNodeNext
        if(associated(posRNodeNext)) posRNodeNext%prev => posLNode
        posRNode%prev => posLNodePrev
        posLNodeNext%prev => posRNode
        posLNode%prev => posRNodePrev
      end if

      if(posR == nList) list%entry => posLNode
    end subroutine swap<%= t %>

    subroutine copy<%= t %>(new, original)
      type(<%= t.list_type %>), intent(inout):: new
      type(<%= t.list_type %>), intent(in):: original

      new = array_from_list(original)
    end subroutine copy<%= t %>

    function array_from_list<%= t %>(list) result(this)
      <%= t.declare %>, allocatable:: this(:)
      type(<%= t.list_type %>), intent(in):: list

      this = list
    end function array_from_list<%= t %>

    subroutine list_from_array_coercion<%= t %>(list, array)
      type(<%= t.list_type %>), intent(inout):: list
      <%= t.declare %>, intent(in):: array(:)

      integer:: i

      if(.not.is_empty(list)) call clear(list)

      do i = lbound(array, 1), ubound(array, 1)
        call push(list, array(i))
      end do
    end subroutine list_from_array_coercion<%= t %>

    subroutine array_from_list_coercion<%= t %>(array, list)
      <%= t.declare %>, allocatable, intent(out):: array(:)
      type(<%= t.list_type %>), intent(in):: list

      integer:: i, nList
      type(<%= t.list_node_type %>), pointer:: walker

      nList = size(list)
      allocate(array(1:nList))
      if(is_empty(list)) return

      i = nList
      walker => list%entry
      array(i) = walker%val
      do while(i > 1)
        walker => walker%prev
        i = i - 1
        array(i) = walker%val
      end do
    end subroutine array_from_list_coercion<%= t %>

    function val_at<%= t %>(list, pos) result(this)
      <%= t.declare %>:: this
      type(<%= t.list_type %>), intent(in):: list
      integer, intent(in):: pos

      type(<%= t.list_node_type %>), pointer:: targetNode

      targetNode => node_at(list, pos)
      this = targetNode%val
    end function val_at<%= t %>

    function shift<%= t %>(list) result(this)
      <%= t.declare %>:: this
      type(<%= t.list_type %>), intent(inout):: list

      this = delete_at(list, 1)
    end function shift<%= t %>

    subroutine unshift<%= t %>(list, val)
      type(<%= t.list_type %>), intent(inout):: list
      <%= t.declare %>, intent(in):: val

      call insert_at(list, val, 1)
    end subroutine unshift<%= t %>

    function delete_at<%= t %>(list, pos) result(this)
      <%= t.declare %>:: this
      type(<%= t.list_type %>), intent(inout):: list
      integer:: pos

      type(<%= t.list_node_type %>), pointer:: targetNode

      if(pos == size(list))then
        this = pop(list)
        return
      end if

      targetNode => node_at(list, pos)
      this = targetNode%val
      if(associated(targetNode%prev)) targetNode%prev%next => targetNode%next
      targetNode%next%prev => targetNode%prev
      deallocate(targetNode)
    end function delete_at<%= t %>

    function pop<%= t %>(list) result(this)
      <%= t.declare %>:: this
      type(<%= t.list_type %>), intent(inout):: list

      type(<%= t.list_node_type %>), pointer:: targetNode

      targetNode => list%entry
      this = targetNode%val
      if(is_size_one(list))then
        deallocate(list%entry)
        return
      end if

      list%entry => targetNode%prev
      list%entry%next => targetNode%next

      deallocate(targetNode)
    end function pop<%= t %>

    recursive subroutine clear<%= t %>(list)
      type(<%= t.list_type %>), intent(inout):: list

      <%= t.declare %>:: trash

      do while(associated(list%entry))
        trash = pop(list)
      end do
    end subroutine clear<%= t %>

    subroutine insert_at<%= t %>(list, val, pos)
      type(<%= t.list_type %>), intent(inout):: list
      <%= t.declare %>, intent(in):: val
      integer, intent(in):: pos

      type(<%= t.list_node_type %>), pointer:: nextNode, newNode

      if(pos == size(list) + 1)then
        call push(list, val)
        return
      end if

      nextNode => node_at(list, pos)
      allocate(newNode)
      newNode%val = val
      newNode%prev => nextNode%prev
      newNode%next => nextNode
    end subroutine insert_at<%= t %>

    subroutine push<%= t %>(list, val)
      type(<%= t.list_type %>), intent(inout):: list
      <%= t.declare %>, intent(in):: val

      type(<%= t.list_node_type %>), pointer:: newNode

      if(is_empty(list))then
        call new(list, val)
        return
      end if

      allocate(newNode)
      newNode%val = val
      newNode%prev => list%entry
      newNode%next => list%entry%next
      list%entry%next => newNode
      list%entry => newNode
    end subroutine push<%= t %>

    function node_at<%= t %>(list, pos) result(this)
      type(<%= t.list_node_type %>), pointer:: this
      type(<%= t.list_type %>), intent(in):: list
      integer, intent(in):: pos

      integer:: posNow

      RAISE_IF(pos < 1 .or. size(list) < pos, 'Out of range: pos, size(list) = ', pos, size(list))

      this => list%entry
      posNow = size(list)

      do while(posNow > pos)
        this => this%prev
        posNow = posNow - 1
      end do
    end function node_at<%= t %>

    function is_empty<%= t %>(list) result(this)
      logical:: this
      type(<%= t.list_type %>), intent(in):: list

      this = .not.associated(list%entry)
    end function is_empty<%= t %>

    function is_size_one<%= t %>(list) result(this)
      logical:: this
      type(<%= t.list_type %>), intent(in):: list

      this = (.not.is_empty(list)) .and. (.not.associated(list%entry%prev))
    end function is_size_one<%= t %>

    function size<%= t %>(list) result(this)
      ! "this" is integer since maximum size(array, 1) is huge(0).
      integer:: this
      type(<%= t.list_type %>), intent(in):: list

      type(<%= t.list_node_type %>), pointer:: walker

      if(is_empty(list))then
        this = 0
        return
      end if

      walker => list%entry
      this = 1
      do while(associated(walker%prev))
        walker => walker%prev
        this = this + 1
      end do
    end function size<%= t %>

    subroutine new<%= t %>(list, val)
      type(<%= t.list_type %>), intent(inout):: list
      <%= t.declare %>, intent(in):: val

      if(.not.is_empty(list))then
        call clear(list)
      end if

      allocate(list%entry)
      list%entry%val = val
    end subroutine new<%= t %>
  <%- } -%>
end module lib_list
