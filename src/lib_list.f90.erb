<%
  # Edit here to add your type.
  # YourType should have assignment(=).
  USERS_MODULES_AND_TYPES = {
    # lib_your_type: ['YourType',],
  }

  class Type
    attr_reader :type, :val

    def initialize(type, is_intrinsic = true)
      @type = if is_intrinsic
                type
              else
                "type(#{type})"
              end
      @val = list(type)
    end

    private

    def list(str)
      str.gsub(/(?:\A|\W)(\w)/){$1.upcase}.gsub(/\W/, '') + 'List'
    end
  end

  USER_DEFINED_TYPES = USERS_MODULES_AND_TYPES\
    .values\
    .flatten\
    .map{|t| Type.new(t, false)}

  INTRINSIC_TYPES = (
                     [
                      'integer',
                      'integer(8)',
                      'real',
                      'double precision',
                      'complex',
                      'complex(kind(0.0d0))',
                      'logical',
                     ] + (0..13).map{|i| "character(len = #{2**i})"})\
    .map{|t| Type.new(t)}

  TYPES = INTRINSIC_TYPES + USER_DEFINED_TYPES
%>

module lib_list
  use lib_util, only: check
  <% USERS_MODULES_AND_TYPES.each{|m, t| %>
    use <%= m %>
  <% } %>

  implicit none

  private

  public:: new       ! Create a size 1 list.
  public:: size      ! Size of a list.
  public:: delete_at ! Delete the N-th node and return a value of the node.
  public:: insert_at ! Insert a node to N-th position.
  ! list: -(1)-(2)-(3)-(4)-
  !    N: 1   2   3   4   5
  public:: val_at              ! Value at N-th node.
  public:: operator(.val.)     ! Same to val_at.
  public:: node_at             ! N-th node.
  ! WARNING: Returns pointer!
  ! BAD: targetNode =  node_at(list, pos)
  ! OK:  targetNode => node_at(list, pos)
  public:: shift                ! Insert a node to the head.
  public:: unshift ! Delete the head node and return a value of the node.
  public:: push    ! Insert a node to the tail.
  public:: pop  ! Delete the tail node and return a value of the node.
  public:: delete               ! Delete all nodes.
  public:: swap                 ! Swap nodes in a list.
  public:: array_from_list      ! List to array convertor.
  public:: copy                 ! Cleate a deep copy of a list.
  public:: assignment(=)        ! List to array, array to list, deep copy of list.
  public:: is_size_one          ! .true. is size of list is one.
  public:: is_empty             ! .true. is size of list is zero.

  <% TYPES.each{|t| %>
    public:: <%= t.val %>
  <% } %>

  <% TYPES.each{|t| %>
    type <%= t.val %>Node
      <%= t.type %>:: val
      type(<%= t.val %>Node), pointer:: prev => null()
      type(<%= t.val %>Node), pointer:: next => null()
    end type <%= t.val %>Node

    type <%= t.val %>
      type(<%= t.val %>Node), pointer:: entry => null()
    end type <%= t.val %>
  <% } %>

  <% TYPES.each{|t| %>
    interface new
      module procedure new_<%= t.val %>
    end interface

    interface size
      module procedure size_<%= t.val %>
    end interface

    interface delete_at
      module procedure delete_at_<%= t.val %>
    end interface

    interface insert_at
      module procedure insert_at_<%= t.val %>
    end interface

    interface val_at
      module procedure val_at_<%= t.val %>
    end interface

    interface operator(.val.)
      module procedure val_at_<%= t.val %>
    end interface

    interface node_at
      module procedure node_at_<%= t.val %>
    end interface

    interface shift
      module procedure shift_<%= t.val %>
    end interface

    interface unshift
      module procedure unshift_<%= t.val %>
    end interface

    interface push
      module procedure push_<%= t.val %>
    end interface

    interface pop
      module procedure pop_<%= t.val %>

    end interface

    interface delete
      module procedure delete_<%= t.val %>
    end interface

    interface swap
      module procedure swap_<%= t.val %>
    end interface

    interface array_from_list
      module procedure array_from_list_<%= t.val %>
    end interface

    interface copy
      module procedure copy_<%= t.val %>
    end interface

    interface assignment(=)
      module procedure copy_<%= t.val %>
      module procedure list_from_array_coercion_<%= t.val %>
      module procedure array_from_list_coercion_<%= t.val %>
    end interface

    interface is_size_one
      module procedure is_size_one_<%= t.val %>
    end interface

    interface is_empty
      module procedure is_empty_<%= t.val %>
    end interface
  <% } %>

contains

  <% TYPES.each{|t| %>
    subroutine swap_<%= t.val %>(list, pos1, pos2)
      type(<%= t.val %>), intent(inout):: list
      integer, intent(in):: pos1, pos2

      type(<%= t.val %>Node), pointer:: posLNodePrev, posLNode, posLNodeNext
      type(<%= t.val %>Node), pointer:: posRNodePrev, posRNode, posRNodeNext
      integer:: posL, posR, nList

      posL = min(pos1, pos2)
      posR = max(pos1, pos2)
      nList = size(list)
      call check(1 <= posL .and. posR <= nList, "swap: Out of range: [pos1, posR] = ", [pos1, posR])
      if(posL == posR) return

      posLNode => node_at(list, posL)
      posLNodePrev => posLNode%prev
      posRNode => node_at(list, posR)
      posRNodeNext => posRNode%next
      if(posR - posL == 1)then
        if(associated(posLNodePrev)) posLNodePrev%next => posRNode
        posLNode%next => posRNodeNext
        posRNode%next => posLNode
        if(associated(posRNodeNext)) posRNodeNext%prev => posLNode
        posRNode%prev => posLNodePrev
        posLNode%prev => posRNode
      else
        posLNodeNext => posLNode%next
        posRNodePrev => posRNode%prev

        if(associated(posLNodePrev)) posLNodePrev%next => posRNode
        posLNode%next => posRNodeNext
        posRNodePrev%next => posLNode
        posRNode%next => posLNodeNext
        if(associated(posRNodeNext)) posRNodeNext%prev => posLNode
        posRNode%prev => posLNodePrev
        posLNodeNext%prev => posRNode
        posLNode%prev => posRNodePrev
      end if

      if(posR == nList) list%entry => posLNode
    end subroutine swap_<%= t.val %>

    subroutine copy_<%= t.val %>(new, original)
      type(<%= t.val %>), intent(inout):: new
      type(<%= t.val %>), intent(in):: original

      new = array_from_list(original)
    end subroutine copy_<%= t.val %>

    function array_from_list_<%= t.val %>(list) result(this)
      <%= t.type %>, allocatable:: this(:)
      type(<%= t.val %>), intent(in):: list

      this = list
    end function array_from_list_<%= t.val %>

    subroutine list_from_array_coercion_<%= t.val %>(list, array)
      type(<%= t.val %>), intent(inout):: list
      <%= t.type %>, intent(in):: array(:)

      integer:: i

      if(.not.is_empty(list)) call delete(list)

      do i = lbound(array, 1), ubound(array, 1)
        call push(list, array(i))
      end do
    end subroutine list_from_array_coercion_<%= t.val %>

    subroutine array_from_list_coercion_<%= t.val %>(array, list)
      <%= t.type %>, allocatable, intent(out):: array(:)
      type(<%= t.val %>), intent(in):: list

      integer:: i
      type(<%= t.val %>Node), pointer:: walker

      i = size(list)
      allocate(array(1:i))
      if(is_empty(list)) return

      walker => list%entry
      array(i) = walker%val
      do while(i > 1)
        walker => walker%prev
        i = i - 1
        array(i) = walker%val
      end do
    end subroutine array_from_list_coercion_<%= t.val %>

    function val_at_<%= t.val %>(list, pos) result(this)
      <%= t.type %>:: this
      type(<%= t.val %>), intent(in):: list
      integer, intent(in):: pos

      type(<%= t.val %>Node), pointer:: targetNode

      targetNode => node_at(list, pos)
      this = targetNode%val
    end function val_at_<%= t.val %>

    function unshift_<%= t.val %>(list) result(this)
      <%= t.type %>:: this
      type(<%= t.val %>), intent(inout):: list

      this = delete_at(list, 1)
    end function unshift_<%= t.val %>

    subroutine shift_<%= t.val %>(list, val)
      type(<%= t.val %>), intent(inout):: list
      <%= t.type %>, intent(in):: val

      call insert_at(list, val, 1)
    end subroutine shift_<%= t.val %>

    function delete_at_<%= t.val %>(list, pos) result(this)
      <%= t.type %>:: this
      type(<%= t.val %>), intent(inout):: list
      integer:: pos

      type(<%= t.val %>Node), pointer:: targetNode

      if(pos == size(list))then
        this = pop(list)
        return
      end if

      targetNode => node_at(list, pos)
      this = targetNode%val
      if(associated(targetNode%prev)) targetNode%prev%next => targetNode%next
      targetNode%next%prev => targetNode%prev
      deallocate(targetNode)
    end function delete_at_<%= t.val %>

    function pop_<%= t.val %>(list) result(this)
      <%= t.type %>:: this
      type(<%= t.val %>), intent(inout):: list

      type(<%= t.val %>Node), pointer:: targetNode

      targetNode => list%entry
      this = targetNode%val
      if(is_size_one(list))then
        deallocate(list%entry)
        return
      end if

      list%entry => targetNode%prev
      list%entry%next => targetNode%next

      deallocate(targetNode)
    end function pop_<%= t.val %>

    recursive subroutine delete_<%= t.val %>(list)
      type(<%= t.val %>), intent(inout):: list

      <%= t.type %>:: trash

      do while(associated(list%entry))
        trash = pop(list)
      end do
    end subroutine delete_<%= t.val %>

    subroutine insert_at_<%= t.val %>(list, val, pos)
      type(<%= t.val %>), intent(inout):: list
      <%= t.type %>, intent(in):: val
      integer, intent(in):: pos

      type(<%= t.val %>Node), pointer:: nextNode, newNode

      if(pos == size(list) + 1)then
        call push(list, val)
        return
      end if

      nextNode => node_at(list, pos)
      allocate(newNode)
      newNode%val = val
      newNode%prev => nextNode%prev
      newNode%next => nextNode
    end subroutine insert_at_<%= t.val %>

    subroutine push_<%= t.val %>(list, val)
      type(<%= t.val %>), intent(inout):: list
      <%= t.type %>, intent(in):: val

      type(<%= t.val %>Node), pointer:: newNode

      if(is_empty(list))then
        call new(list, val)
        return
      end if

      allocate(newNode)
      newNode%val = val
      newNode%prev => list%entry
      newNode%next => list%entry%next
      list%entry%next => newNode
      list%entry => newNode
    end subroutine push_<%= t.val %>

    function node_at_<%= t.val %>(list, pos) result(this)
      type(<%= t.val %>Node), pointer:: this
      type(<%= t.val %>), intent(in):: list
      integer, intent(in):: pos

      integer:: posNow

      call check(1 <= pos .and. pos <= size(list), 'pos out of range: (/size(list), pos/) = ', (/size(list), pos/))

      this => list%entry
      posNow = size(list)

      do while(posNow > pos)
        this => this%prev
        posNow = posNow - 1
      end do
    end function node_at_<%= t.val %>

    function is_empty_<%= t.val %>(list) result(this)
      logical:: this
      type(<%= t.val %>), intent(in):: list

      this = .not.associated(list%entry)
    end function is_empty_<%= t.val %>

    function is_size_one_<%= t.val %>(list) result(this)
      logical:: this
      type(<%= t.val %>), intent(in):: list

      this = (.not.is_empty(list)) .and. (.not.associated(list%entry%prev))
    end function is_size_one_<%= t.val %>

    function size_<%= t.val %>(list) result(this)
      ! arrayとの相互変換を考慮して、integerの範囲に絞る
      integer:: this
      type(<%= t.val %>), intent(in):: list

      type(<%= t.val %>Node), pointer:: walker

      if(is_empty(list))then
        this = 0
        return
      end if

      walker => list%entry
      this = 1
      do while(associated(walker%prev))
        walker => walker%prev
        this = this + 1
      end do
    end function size_<%= t.val %>

    subroutine new_<%= t.val %>(list, val)
      type(<%= t.val %>), intent(inout):: list
      <%= t.type %>, intent(in):: val

      if(.not.is_empty(list))then
        call delete(list)
      end if

      allocate(list%entry)
      list%entry%val = val
    end subroutine new_<%= t.val %>
  <% } %>
end module lib_list
