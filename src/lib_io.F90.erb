<%
  require 'fort'

  TYPES\
  = ::Fort::Type::Logical.multi_provide(dim: (1..7))\
  + ::Fort::Type::Integer.multi_provide(dim: (1..7))\
  + ::Fort::Type::Real.multi_provide(dim: (1..7))\
  + ::Fort::Type::Complex.multi_provide(dim: (1..7))\
  + ::Fort::Type::Character.multi_provide(dim: (1..7))

  def list(n, joint = ', ', &block)
    (1..n).to_a.map(&block).join(joint)
  end

  NUM_DESC_MAX = 10
%>

#include "utils.h"
module lib_io
  use, intrinsic:: iso_fortran_env, only: ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  use lib_constant, only: TAB
  use lib_character, only: s, str, operator(+)
  use lib_queue, only: CharacterDim0Len1Queue, push, shift

  implicit none

  private
  public:: VERSION, ARRAY_DATA_FILE, ARRAY_META_FILE, ARRAY_VERSION_FILE, ARRAY_DESCRIPTION_FILE
  public:: TMP_DIR
  public:: SHELL_INTERFACE_FILE
  public:: new_unit
  public:: write_array, read_array
  public:: number_of_lines, number_of_columns, file_shape
  public:: mkdir_p
  public:: tempfile
  public:: close_tempfile
  public:: init_shell_interface_file
  public:: read_shell_interface_file
  public:: read_line

  integer, parameter:: VERSION = 1 ! Array file format's compatibility.
  integer, parameter:: NEW_UNIT_MIN = max(ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT, 0) + 1 ! 0 is decraled to handle a case where *_UNIT <= -1.
  integer, parameter:: NEW_UNIT_MAX = huge(0)
  character(len = *), parameter:: ARRAY_DATA_FILE = 'data.bin'
  character(len = *), parameter:: ARRAY_META_FILE = 'meta.nml'
  character(len = *), parameter:: ARRAY_VERSION_FILE = 'version.dat'
  character(len = *), parameter:: ARRAY_DESCRIPTION_FILE = 'description.txt'
  character(len = *), parameter:: TMP_DIR = 'tmp'
  ! Non-intrinsic function `+' can not be used in initialization expression.
  character(len = *), parameter:: SHELL_INTERFACE_FILE = TMP_DIR // '/' // 'shell_interface.dat'

  interface new_unit
    <%- ::Fort::Type::Integer.multi_provide(dim: 0).each{|t| -%>
      module procedure new_unit<%= t %>
    <%- } -%>
  end interface new_unit

  <%- TYPES.each{|t| -%>
    interface write_array
      module procedure write_array<%= t %>
    end interface write_array

    interface read_array
      module procedure read_array<%= t %>
    end interface read_array

    interface read_array_v_1
      module procedure read_array_v_1<%= t %>
    end interface read_array_v_1
  <%- } -%>

contains

  ! str
  !   space:              retained
  !   new line character: removed
  function read_line(io, str) result(isSuccess)
    Integer, intent(in):: io
    Character(len = :), allocatable, intent(out):: str
    Logical:: isSuccess

    Character:: c
    type(CharacterDim0Len1Queue):: queue
    Integer:: nQueue, i
    Integer:: ios

    isSuccess = .false.
    nQueue = 0
    do
      read(io, '(a1)', advance = 'no', iostat = ios) c
      if(is_iostat_ok(ios))then
        call push(queue, c)
        nQueue = nQueue + 1
      else if(is_iostat_eor(ios) .or. is_iostat_end(ios))then
        exit
      else
        isSuccess = .false.
        return
      end if
    end do

    allocate(Character(len = nQueue):: str)
    do i = 1, nQueue
      isSuccess = shift(queue, c)
      debug_assert(isSuccess)
      str(i:i) = c
    end do

    isSuccess = .true.
  end function read_line

  subroutine init_shell_interface_file()
    call mkdir_p(TMP_DIR)
    call execute_command_line("cat /dev/null > " + SHELL_INTERFACE_FILE)
  end subroutine init_shell_interface_file

  ! YAGNI: this can easily expand to val for r, R, i, I, z, Z, and l.
  subroutine read_shell_interface_file(val)
    character(len = *), intent(out):: val

    integer:: ioU

    call new_unit(ioU)
    open(ioU, file = SHELL_INTERFACE_FILE, status = 'old', action = 'read')
    read(ioU, *) val
    close(ioU)
  end subroutine read_shell_interface_file

  subroutine tempfile(ioU, file)
    integer, intent(out):: ioU
    character(len = *), intent(out):: file

    call init_shell_interface_file()
    ! tempfile name must be quoted since '/' mark is regarded to be end of record (same as namelist).
    call execute_command_line('echo \"$(tempfile)\" > ' + SHELL_INTERFACE_FILE)
    call read_shell_interface_file(file)
    call new_unit(ioU)
    open(ioU, file = s(file), status = 'old', action = 'readwrite')
  end subroutine tempfile

  subroutine close_tempfile(ioU)
    integer, intent(in):: ioU

    close(ioU, status = 'delete')
  end subroutine close_tempfile

  subroutine mkdir_p(path, exitStatus)
    character(len = *) path
    integer, intent(out), optional:: exitStatus
    integer:: exitStatus_
    call execute_command_line("mkdir -p " + s(path), .true., exitStatus_)

    if(present(exitStatus))then
      exitStatus = exitStatus_
    elseif(exitStatus_ /= 0)then
      raise('Failed to execute mkdir -p ' + s(path))
    end if
  end subroutine mkdir_p

  ! @desc Return a size 2 array which contains (/numberOfLines, numberOfColumns/) of the file fileName.
  function file_shape(fileName, numberOfHeaders) result(this)
    integer(8):: this(1:2)
    character(len = *), intent(in):: fileName
    integer, intent(in), optional:: numberOfHeaders

    integer:: numberOfHeaders_

    numberOfHeaders_ = 0
    if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

    this = (/number_of_lines(fileName) - numberOfHeaders_, number_of_columns(fileName, numberOfHeaders_)/)
  end function file_shape

  function number_of_lines(fileName) result(this)
    integer(8):: this
    character(len = *), intent(in):: fileName

    integer:: rU1, ios
    character:: dummy

    call new_unit(rU1)
    open(rU1, file = fileName, status = 'old', action = 'read', delim = 'quote')

    this = 0
    do
      read(rU1, *, iostat = ios) dummy
      if(is_iostat_bad(ios)) exit
      raise_if(this >= huge(this))

      this = this + 1
    end do
    close(rU1)
  end function number_of_lines

  ! @desc Return number of columns at line (numberOfHeaders + 1) in file fileName.
  ! @desc The line is separated by space and tabs character.
  ! @desc Quoted string containing space/tab characteres is not considared.
  function number_of_columns(fileName, numberOfHeaders) result(this)
    integer(8):: this
    character(len = *), intent(in):: fileName
    integer, intent(in), optional:: numberOfHeaders

    enum, bind(c)
      enumerator:: SEEK_NORMAL_CHAR, SEEK_SEPARATOR
    end enum
    character, parameter:: SEPARATORS(1:2) = [' ', TAB]

    integer:: rU1, ios, i, mode
    character:: c

    integer:: numberOfHeaders_

    numberOfHeaders_ = 0
    if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

    mode = SEEK_NORMAL_CHAR
    this = 0
    call new_unit(rU1)
    open(rU1, file = fileName, status = 'old', action = 'read', delim = 'quote')
    do i = 1, numberOfHeaders_
      read(rU1, *)
    end do
    do
      read(rU1, '(a1)', advance = 'no', iostat = ios) c
      if(is_iostat_bad(ios) .or. c == new_line('_')) exit

      select case(mode)
      case(SEEK_SEPARATOR)
        if(has_val(SEPARATORS, c)) mode = SEEK_NORMAL_CHAR
      case(SEEK_NORMAL_CHAR)
        if(.not.has_val(SEPARATORS, c))then
          raise_if(this >= huge(this))

          this = this + 1
          mode = SEEK_SEPARATOR
        end if
      end select
    end do
    close(rU1)
  end function number_of_columns

  <%- TYPES.each{|t| -%>
    subroutine write_array<%= t %>(arrayDir, array<%= list(NUM_DESC_MAX, ''){|i| ", desc#{i}"} %>)
      character(len = *), intent(in):: arrayDir
      <%= t.declare %>, intent(in):: array
      <%- if NUM_DESC_MAX >= 1 -%>
        character(len = *), intent(in), optional:: <%= list(NUM_DESC_MAX){|i| "desc#{i}"} %>
      <%- end -%>

      character(len = *), parameter:: DATA_TYPE_FOR_SELF = '<%= t %>'
      integer, parameter:: DIM_FOR_SELF = <%= t.dim %>

      character(len = len(DATA_TYPE_FOR_SELF)) dataType
      integer:: dim
      integer:: sizes(1:DIM_FOR_SELF)
      integer:: wU1
      integer:: i

      namelist /array_meta/ dataType, dim, sizes

      call mkdir_p(s(arrayDir))

      call new_unit(wU1)
      open(unit = wU1, file = s(arrayDir) + '/' + ARRAY_VERSION_FILE, status = 'replace', action = 'write')
      write(wU1, *) VERSION
      close(wU1)

      call new_unit(wU1)
      open(unit = wU1, file = s(arrayDir) + '/' + ARRAY_DATA_FILE, status = 'replace', action = 'write', form = 'unformatted', access = 'stream')
      write(wU1) array
      close(wU1)

      dataType = DATA_TYPE_FOR_SELF
      dim = DIM_FOR_SELF
      forall(i = 1:dim) sizes(i) = size(array, i)
      call new_unit(wU1)
      open(unit = wU1, file = s(arrayDir) + '/' + ARRAY_META_FILE, status = 'replace', action = 'write', delim = 'quote')
      write(wU1, nml = array_meta)
      close(wU1)

      open(unit = wU1, file = s(arrayDir) + '/' + ARRAY_DESCRIPTION_FILE, status = 'replace', action = 'write')
      <%- (1..NUM_DESC_MAX).each{|i| -%>
        if(present(desc<%= i %>)) write(wU1, *) desc<%= i %>
      <%- } -%>
      close(wU1)
    end subroutine write_array<%= t %>

    subroutine read_array<%= t %>(arrayDir, array)
      character(len = *), intent(in):: arrayDir
      <%= t.declare %>, intent(out), allocatable:: array

      integer:: rU1, libIoVersion

      call new_unit(rU1)
      open(unit = rU1, file = s(arrayDir) + '/' + ARRAY_VERSION_FILE, status = 'old', action = 'read')
      read(rU1, *) libIoVersion
      close(rU1)

      select case(libIoVersion)
      case(1)
        call read_array_v_1(arrayDir, array)
      case default
        raise('Unsupported version: ' + str(libIoVersion))
      end select
    end subroutine read_array<%= t %>

    subroutine read_array_v_1<%= t %>(arrayDir, array)
      character(len = *), intent(in):: arrayDir
      <%= t.declare %>, intent(out), allocatable:: array

      character(len = *), parameter:: DATA_TYPE_FOR_SELF = '<%= t %>'
      integer, parameter:: DIM_FOR_SELF = <%= t.dim %>
      character(len = <%= TYPES.map{|_| _.to_s.size}.max %>):: dataType
      integer:: dim
      integer:: sizes(1:DIM_FOR_SELF)
      integer:: rU1
      namelist /array_meta/ dataType, dim, sizes

      call new_unit(rU1)
      open(unit = rU1, file = s(arrayDir) + '/' + ARRAY_META_FILE, status = 'old', action = 'read', delim = 'quote')
      read(rU1, nml = array_meta)

      raise_if(s(dataType) /= DATA_TYPE_FOR_SELF)
      raise_if(dim /= DIM_FOR_SELF)

      close(rU1)

      allocate(array(<%= list(t.dim){|i| "1:sizes(#{i})"} %>))

      call new_unit(rU1)
      open(unit = rU1, file = s(arrayDir) + '/' + ARRAY_DATA_FILE, status = 'old', action = 'read', form = 'unformatted', access = 'stream')
      read(rU1) array
    end subroutine read_array_v_1<%= t %>
  <%- } -%>


  <%- ::Fort::Type::Integer.multi_provide(dim: 0).each{|t| -%>
    subroutine new_unit<%= t %>(n)
      <%= t.declare %>, intent(out):: n
      integer(kind(n)):: i
      logical:: isOpened

      do i = NEW_UNIT_MIN, min(huge(n), NEW_UNIT_MAX)
        inquire(unit = i, opened = isOpened)
        if(.not.(isOpened))then
          n = i
          return
        end if
      end do

      raise('No available unit number exist between: ' + str(NEW_UNIT_MIN) + ' and ' + str(NEW_UNIT_MAX))
    end subroutine new_unit<%= t %>
  <%- } -%>
end module lib_io
