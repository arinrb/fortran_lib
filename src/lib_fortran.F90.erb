<%-
require 'fort'
TYPES\
= ::Fort::Type::Real.multi_provide\
+ ::Fort::Type::Integer.multi_provide\
+ ::Fort::Type::Logical.multi_provide\
+ ::Fort::Type::Complex.multi_provide\
+ ::Fort::Type::Character.multi_provide(len: (0..13).map{|n| 2**n})
-%>

module lib_fortran
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  implicit none

  private


  ! = public routine
  public:: push                 ! Queue, Stack
  public:: shift                ! Queue
  public:: pop                  ! Stack


  ! = public type
  ! == Object
  public:: Object

  ! == Queue
  public:: Queue
  <%- TYPES.each{|t| -%>
    public:: <%= t %>Queue
  <%- } -%>

  ! == Stack
  public:: Stack
  <%- TYPES.each{|t| -%>
    public:: <%= t %>Stack
  <%- } -%>


  ! = interface
  ! == Queue
  <%- TYPES.each{|t| -%>
    interface push
      module procedure push<%= t %>Queue
    end interface push

    interface shift
      module procedure shift<%= t %>Queue
    end interface shift

    interface is_empty
      module procedure is_empty<%= t %>Queue
    end interface is_empty
  <%- } -%>

  ! == Stack
  <%- TYPES.each{|t| -%>
    interface push
      module procedure push<%= t %>Stack
    end interface push

    interface pop
      module procedure pop<%= t %>Stack
    end interface pop

    interface is_empty
      module procedure is_empty<%= t %>Stack
    end interface is_empty
  <%- } -%>


  ! = type
  ! = Object
  type:: Object
  end type Object

  ! == Queue
  type, extends(Object):: Queue
  end type Queue

  type, extends(Object):: QueueNode
  end type QueueNode

  <%- TYPES.each{|t| -%>
    type, extends(Queue):: <%= t %>Queue
      type(<%= t %>QueueNode), pointer:: tail => null()
      type(<%= t %>QueueNode), pointer:: head => null()
    end type <%= t %>Queue

    type, extends(QueueNode):: <%= t %>QueueNode
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>:: value
      type(<%= t %>QueueNode), pointer:: next => null()
    end type <%= t %>QueueNode
  <%- } -%>

  ! == Stack
  type, extends(Object):: Stack
  end type Stack

  type, extends(Object):: StackNode
  end type StackNode

  <%- TYPES.each{|t| -%>
    type, extends(Stack):: <%= t %>Stack
      type(<%= t %>StackNode), pointer:: entry => null()
    end type <%= t %>Stack

    type, extends(StackNode):: <%= t %>StackNode
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>:: value
      type(<%= t %>StackNode), pointer:: prev => null()
    end type <%= t %>StackNode
  <%- } -%>


contains


  ! = body
  ! == Queue
  <%- TYPES.each{|t| -%>
    subroutine push<%= t %>Queue(queue, value)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %>, intent(in):: value
      type(<%= t %>QueueNode), pointer:: newNode

      allocate(newNode)
      newNode%value = value

      ! ! If user defined type allows member variables with the target attribute, I would define Queue as:
      ! type <%= t %>Queue
      !   type(<%= t %>QueueNode), target:: root
      !   type(<%= t %>QueueNode), pointer:: tail => root
      !   type(<%= t %>QueueNode), pointer:: head => root%next
      ! end type <%= t %>Queue
      ! ! and the following if-statement could be simplified as:
      ! queue%tail%next => newNode
      if(is_empty(queue))then
        queue%head => newNode
      else
        queue%tail%next => newNode
      end if
      queue%tail => newNode
    end subroutine push<%= t %>Queue

    function shift<%= t %>Queue(queue, value) result(isSuccess)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>, intent(inout):: value
      Logical:: isSuccess
      type(<%= t %>QueueNode), pointer:: tmpNodeHolder => null()

      if(is_empty(queue))then
        isSuccess = .false.
        return
      end if

      value = queue%head%value
      tmpNodeHolder => queue%head
      queue%head => queue%head%next
      deallocate(tmpNodeHolder)
      isSuccess = .true.
    end function shift<%= t %>Queue

    function is_empty<%= t %>Queue(queue) result(answer)
      type(<%= t %>Queue), intent(in):: queue
      Logical:: answer

      answer = .not.associated(queue%head)
    end function is_empty<%= t %>Queue
  <%- } -%>

  ! == Stack
  <%- TYPES.each{|t| -%>
    subroutine push<%= t %>Stack(stack, value)
      type(<%= t %>Stack), intent(inout):: stack
      <%= t.declare %>, intent(in):: value
      type(<%= t %>StackNode), pointer:: newNode

      allocate(newNode)
      newNode%value = value
      newNode%prev => stack%entry
      stack%entry => newNode
    end subroutine push<%= t %>Stack

    function pop<%= t %>Stack(stack, value) result(isSuccess)
      type(<%= t %>Stack), intent(inout):: stack
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>, intent(inout):: value
      Logical:: isSuccess
      type(<%= t %>StackNode), pointer:: tmpNodeHolder => null()

      if(is_empty(stack))then
        isSuccess = .false.
        return
      end if

      value = stack%entry%value
      tmpNodeHolder => stack%entry
      stack%entry => stack%entry%prev
      deallocate(tmpNodeHolder)
      isSuccess = .true.
    end function pop<%= t %>Stack

    function is_empty<%= t %>Stack(stack) result(answer)
      type(<%= t %>Stack), intent(in):: stack
      Logical:: answer

      answer = .not.associated(stack%entry)
    end function is_empty<%= t %>Stack
  <%- } -%>
end module lib_fortran
