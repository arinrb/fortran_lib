<%-
  require 'fort'
  LOG_2_CHAR_LEN_MAX = 8
  REALS = ::Fort::Type::Real.multi_provide
  INTEGERS = ::Fort::Type::Integer.multi_provide
  LOGICALS = ::Fort::Type::Logical.multi_provide
  COMPLEXES = ::Fort::Type::Complex.multi_provide
  CHARACTERS = ::Fort::Type::Character.multi_provide(len: (0..LOG_2_CHAR_LEN_MAX).map{|n| 2**n})
  TYPES\
  = REALS\
  + INTEGERS\
  + LOGICALS\
  + COMPLEXES\
  + CHARACTERS
  CHARACTERS_DIM0_BY_TYPES = ::Fort::Type::Character.multi_provide(dim: 0, len: (0..LOG_2_CHAR_LEN_MAX).map{|n| 2**n}).product(TYPES)
-%>

# include "utils.h"
module lib_fortran
  USE_UTILS_H
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  implicit none

  private


  ! = public routine
  public:: push                 ! Queue, Stack
  public:: shift                ! Queue
  public:: pop                  ! Stack
  public:: add                  ! BinaryTreeMap
  public:: has_key              ! BinaryTreeMap
  public:: get_value            ! BinaryTreeMap


  ! = public type
  ! == Object
  public:: Object

  ! == Queue
  public:: Queue
  <%- TYPES.each{|t| -%>
    public:: <%= t %>Queue
  <%- } -%>

  ! == Stack
  public:: Stack
  <%- TYPES.each{|t| -%>
    public:: <%= t %>Stack
  <%- } -%>

  ! == BinaryTreeMap
  public:: BinaryTreeMap
  <%- CHARACTERS_DIM0_BY_TYPES.each{|key_type, value_type| -%>
    public:: <%= key_type %><%= value_type %>BinaryTreeMap
  <%- } -%>

  ! = interface
  ! == Queue
  <%- TYPES.each{|t| -%>
    interface push
      module procedure push<%= t %>Queue
    end interface push

    interface shift
      module procedure shift<%= t %>Queue
    end interface shift

    interface is_empty
      module procedure is_empty<%= t %>Queue
    end interface is_empty
  <%- } -%>

  ! == Stack
  <%- TYPES.each{|t| -%>
    interface push
      module procedure push<%= t %>Stack
    end interface push

    interface pop
      module procedure pop<%= t %>Stack
    end interface pop

    interface is_empty
      module procedure is_empty<%= t %>Stack
    end interface is_empty
  <%- } -%>

  ! == BinaryTreeMap
  <%- CHARACTERS_DIM0_BY_TYPES.each{|key_type, value_type| -%>
    interface add
      module procedure:: add<%= key_type %><%= value_type %>BinaryTreeMap
      module procedure:: add<%= key_type %><%= value_type %>BinaryTreeMapNode
    end interface add

    interface has_key
      module procedure:: has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMap
      module procedure:: has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode
    end interface has_key

    interface get_value
      module procedure:: get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMap
      module procedure:: get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode
    end interface get_value
  <%- } -%>


  ! = type
  ! = Object
  type:: Object
  end type Object

  ! == Queue
  type, extends(Object):: Queue
  end type Queue

  type, extends(Object):: QueueNode
  end type QueueNode

  <%- TYPES.each{|t| -%>
    type, extends(Queue):: <%= t %>Queue
      type(<%= t %>QueueNode), pointer:: tail => null()
      type(<%= t %>QueueNode), pointer:: head => null()
    end type <%= t %>Queue

    type, extends(QueueNode):: <%= t %>QueueNode
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>:: value
      type(<%= t %>QueueNode), pointer:: next => null()
    end type <%= t %>QueueNode
  <%- } -%>

  ! == Stack
  type, extends(Object):: Stack
  end type Stack

  type, extends(Object):: StackNode
  end type StackNode

  <%- TYPES.each{|t| -%>
    type, extends(Stack):: <%= t %>Stack
      type(<%= t %>StackNode), pointer:: entry => null()
    end type <%= t %>Stack

    type, extends(StackNode):: <%= t %>StackNode
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>:: value
      type(<%= t %>StackNode), pointer:: prev => null()
    end type <%= t %>StackNode
  <%- } -%>

  ! == BinaryTreeMap
  type, extends(Object):: BinaryTreeMap
  end type BinaryTreeMap

  type, extends(Object):: BinaryTreeMapNode
  end type BinaryTreeMapNode

  <%- CHARACTERS_DIM0_BY_TYPES.each{|key_type, value_type| -%>
    type, extends(BinaryTreeMap):: <%= key_type %><%= value_type %>BinaryTreeMap
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer:: root => null()
    end type <%= key_type %><%= value_type %>BinaryTreeMap

    type, extends(BinaryTreeMapNode):: <%= key_type %><%= value_type %>BinaryTreeMapNode
      <%= key_type.declare %>:: key
      <%= value_type.declare %><%= (value_type.dim > 0) ? ', allocatable' : '' %>:: value
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer:: small => null()
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer:: large => null()
    end type <%= key_type %><%= value_type %>BinaryTreeMapNode
  <%- } -%>


contains


  ! = body
  ! == Queue
  <%- TYPES.each{|t| -%>
    subroutine push<%= t %>Queue(queue, value)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %>, intent(in):: value
      type(<%= t %>QueueNode), pointer:: newNode

      allocate(newNode)
      newNode%value = value

      ! ! If user defined type allows member variables with the target attribute, I would define Queue as:
      ! type <%= t %>Queue
      !   type(<%= t %>QueueNode), target:: root
      !   type(<%= t %>QueueNode), pointer:: tail => root
      !   type(<%= t %>QueueNode), pointer:: head => root%next
      ! end type <%= t %>Queue
      ! ! and the following if-statement could be simplified as:
      ! queue%tail%next => newNode
      if(is_empty(queue))then
        queue%head => newNode
      else
        queue%tail%next => newNode
      end if
      queue%tail => newNode
    end subroutine push<%= t %>Queue

    function shift<%= t %>Queue(queue, value) result(isSuccess)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>, intent(inout):: value
      Logical:: isSuccess
      type(<%= t %>QueueNode), pointer:: removedNode => null()

      if(is_empty(queue))then
        isSuccess = .false.
        return
      end if

      value = queue%head%value
      removedNode => queue%head
      queue%head => queue%head%next
      deallocate(removedNode)
      isSuccess = .true.
    end function shift<%= t %>Queue

    function is_empty<%= t %>Queue(queue) result(answer)
      type(<%= t %>Queue), intent(in):: queue
      Logical:: answer

      answer = .not.associated(queue%head)
    end function is_empty<%= t %>Queue
  <%- } -%>

  ! == Stack
  <%- TYPES.each{|t| -%>
    subroutine push<%= t %>Stack(stack, value)
      type(<%= t %>Stack), intent(inout):: stack
      <%= t.declare %>, intent(in):: value
      type(<%= t %>StackNode), pointer:: newNode

      allocate(newNode)
      newNode%value = value
      newNode%prev => stack%entry
      stack%entry => newNode
    end subroutine push<%= t %>Stack

    function pop<%= t %>Stack(stack, value) result(isSuccess)
      type(<%= t %>Stack), intent(inout):: stack
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>, intent(inout):: value
      Logical:: isSuccess
      type(<%= t %>StackNode), pointer:: removedNode => null()

      if(is_empty(stack))then
        isSuccess = .false.
        return
      end if

      value = stack%entry%value
      removedNode => stack%entry
      stack%entry => stack%entry%prev
      deallocate(removedNode)
      isSuccess = .true.
    end function pop<%= t %>Stack

    function is_empty<%= t %>Stack(stack) result(answer)
      type(<%= t %>Stack), intent(in):: stack
      Logical:: answer

      answer = .not.associated(stack%entry)
    end function is_empty<%= t %>Stack
  <%- } -%>

  ! == BinaryTreeMap
  <%- CHARACTERS_DIM0_BY_TYPES.each{|key_type, value_type| -%>
    subroutine add<%= key_type %><%= value_type %>BinaryTreeMap(self, key, value)
      type(<%= key_type %><%= value_type %>BinaryTreeMap), intent(inout):: self
      Character(len = *), intent(in):: key
      <%= value_type.declare %>, intent(in):: value

      ASSERT(len_trim(key) <= <%= key_type.len %>)
      call add(self%root, key, value)
    end subroutine add<%= key_type %><%= value_type %>BinaryTreeMap

    recursive subroutine add<%= key_type %><%= value_type %>BinaryTreeMapNode(self, key, value)
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer, intent(inout):: self
      Character(len = *), intent(in):: key
      <%= value_type.declare %>, intent(in):: value

      if(associated(self))then
        if(key < self%key)then
          call add(self%small, key, value)
        else if(key > self%key)then
          call add(self%large, key, value)
        else
          self%value = value
        end if
      else
        allocate(self)
        self%key = key
        self%value = value
      end if
    end subroutine add<%= key_type %><%= value_type %>BinaryTreeMapNode

    function has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMap(self, key) result(answer)
      type(<%= key_type %><%= value_type %>BinaryTreeMap), intent(in):: self
      Character(len = *), intent(in):: key
      Logical:: answer

      if(len_trim(key) <= <%= key_type.len %>)then
        answer = has_key(self%root, key)
      else
        answer = .false.
      end if
    end function has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMap

    recursive function has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode(self, key) result(answer)
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer, intent(in):: self
      Character(len = *), intent(in):: key
      Logical:: answer

      if(associated(self))then
        if(key < self%key)then
          answer = has_key(self%small, key)
        else if(key > self%key)then
          answer = has_key(self%large, key)
        else
          answer = .true.
        end if
      else
        answer = .false.
      end if
    end function has_key<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode

    function get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMap(self, key, value) result(isSuccess)
      type(<%= key_type %><%= value_type %>BinaryTreeMap), intent(inout):: self
      Character(len = *), intent(in):: key
      <%= value_type.declare %><%= (value_type.dim > 0) ? ', allocatable' : '' %>, intent(out):: value
      Logical:: isSuccess

      if(len_trim(key) <= <%= key_type.len %>)then
        isSuccess = get_value(self%root, key, value)
      else
        isSuccess = .false.
      end if
    end function get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMap

    recursive function get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode(self, key, value) result(isSuccess)
      type(<%= key_type %><%= value_type %>BinaryTreeMapNode), pointer, intent(in):: self
      Character(len = *), intent(in):: key
      <%= value_type.declare %><%= (value_type.dim > 0) ? ', allocatable' : '' %>, intent(out):: value
      Logical:: isSuccess

      if(associated(self))then
        if(key < self%key)then
          isSuccess = get_value(self%small, key, value)
        else if(key > self%key)then
          isSuccess = get_value(self%large, key, value)
        else
          value = self%value
          isSuccess = .true.
        end if
      else
        isSuccess = .false.
      end if
    end function get_value<%= key_type.id %><%= value_type.id %>BinaryTreeMapNode
  <%- } -%>
end module lib_fortran
