<%-
require 'fort'
TYPES\
= ::Fort::Type::Real.multi_provide\
+ ::Fort::Type::Integer.multi_provide\
+ ::Fort::Type::Logical.multi_provide\
+ ::Fort::Type::Complex.multi_provide\
+ ::Fort::Type::Character.multi_provide(len: (0..13).map{|n| 2**n})
-%>

module lib_queue
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  implicit none

  private
  public:: push, shift

  <%- TYPES.each{|t| -%>
    public:: <%= t %>Queue
  <%- } -%>

  <%- TYPES.each{|t| -%>
    interface push
      module procedure push<%= t %>
    end interface push

    interface shift
      module procedure shift<%= t %>
    end interface shift

    interface is_empty
      module procedure is_empty<%= t %>
    end interface is_empty
  <%- } -%>

  <%- TYPES.each{|t| -%>
    type <%= t %>Queue
      type(<%= t %>QueueNode), pointer:: tail => null()
      type(<%= t %>QueueNode), pointer:: head => null()
    end type <%= t %>Queue

    type <%= t %>QueueNode
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>:: val
      type(<%= t %>QueueNode), pointer:: next => null()
    end type <%= t %>QueueNode
  <%- } -%>

contains

  <%- TYPES.each{|t| -%>
    subroutine push<%= t %>(queue, val)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %>, intent(in):: val
      type(<%= t %>QueueNode), pointer:: newNode

      allocate(newNode)
      newNode%val = val

      ! ! If user defined type allows member variables with the target attribute, I would define Queue as:
      ! type <%= t %>Queue
      !   type(<%= t %>QueueNode), target:: root
      !   type(<%= t %>QueueNode), pointer:: tail => root
      !   type(<%= t %>QueueNode), pointer:: head => root%next
      ! end type <%= t %>Queue
      ! ! and the following if-statement could be simplified as:
      ! queue%tail%next => newNode
      if(is_empty(queue))then
        queue%head => newNode
      else
        queue%tail%next => newNode
      end if
      queue%tail => newNode
    end subroutine push<%= t %>

    function shift<%= t %>(queue, val) result(isSuccess)
      type(<%= t %>Queue), intent(inout):: queue
      <%= t.declare %><%= (t.dim > 0) ? ', allocatable' : '' %>, intent(inout):: val
      Logical:: isSuccess
      type(<%= t %>QueueNode), pointer:: tmpNodeHolder => null()

      if(is_empty(queue))then
        isSuccess = .false.
        return
      end if

      val = queue%head%val
      tmpNodeHolder => queue%head
      queue%head => queue%head%next
      deallocate(tmpNodeHolder)
      isSuccess = .true.
    end function shift<%= t %>

    function is_empty<%= t %>(queue) result(answer)
      type(<%= t %>Queue), intent(in):: queue
      Logical:: answer

      answer = .not.associated(queue%head)
    end function is_empty<%= t %>
  <%- } -%>
end module lib_queue
