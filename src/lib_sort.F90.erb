<%-
  require 'fort'

  INTEGERS = ::Fort::Type::Integer.multi_provide(dim: 0)
  REALS = ::Fort::Type::Real.multi_provide(dim: 0)
  TYPES = INTEGERS + REALS
-%>

#include "utils.h"
module lib_sort
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  USE_UTILS_H
  use lib_comparable, only: is_nan, is_infinity

  use lib_stack, only: push, pop
  use lib_stack, only: IntegerDim0KindINT64Stack

  implicit none

  private

  public:: sort_quick, sorting_quick
  public:: sort_merge, sorting_merge

  <%- TYPES.each{|t| -%>
    interface sort_quick
      module procedure sort_quick<%= t %>
    end interface sort_quick

    interface sorting_quick
      module procedure sorting_quick<%= t %>
    end interface sorting_quick

    interface get_pivot
      module procedure get_pivot<%= t %>
    end interface get_pivot

    interface sort_merge
      module procedure sort_merge<%= t %>
    end interface sort_merge

    interface sorting_merge
      module procedure sorting_merge<%= t %>
    end interface sorting_merge

    interface sorting_merge_substance
      module procedure sorting_merge_substance<%= t %>
    end interface sorting_merge_substance

    interface merge_sorted_lists
      module procedure merge_sorted_lists<%= t %>
    end interface merge_sorted_lists

    interface sorting_3
      module procedure sorting_3<%= t %>
    end interface sorting_3

    interface sorting_2
      module procedure sorting_2<%= t %>
    end interface sorting_2

    interface swapping
      module procedure swapping<%= t %>
    end interface swapping
  <%- } -%>

contains

  <%- TYPES.each{|t| -%>
    function sort_quick<%= t %>(xs) result(xsSorted)
      <%= t.declare %>, allocatable:: xsSorted(:)
      <%= t.declare %>, intent(in):: xs(:)

      xsSorted = xs
      call sorting_quick(xsSorted)
    end function sort_quick<%= t %>

    subroutine sorting_quick<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(:)
      <%= t.declare %>:: pivot
      type(IntegerDim0KindINT64Stack):: iLs, iRs
      Integer(kind = INT64):: iL, iR, iLOriginal, iROriginal
      Logical:: isUniform

      raise_if(any(is_nan(xs)))

      call push(iLs, 1_INT64)
      call push(iRs, size(xs, dim = 1, kind = INT64))

      do while(pop(iRs, iR))    ! Loop for all segments on the stacks.
        assert(pop(iLs, iL))

        iLOriginal = iL      ! Left most index of the current segment.
        do while(iLOriginal < iR) ! While current segment remains
          select case(iR - iL)
          case(-1, 0)
            exit
          case(1)
            call sorting_2(xs(iL:iR))
            exit
          case(2)
            call sorting_3(xs(iL:iR))
            exit
          case(3:)
            pivot = get_pivot(xs(iL:iR), isUniform)
            if(isUniform) exit

            iROriginal = iR  ! Right most index of the current segment
            loop_to_swap: do ! Within the segment
              do while(xs(iR) > pivot)
                iR = iR - 1
              end do
              do while(xs(iL) <= pivot)
                if(iL >= iR)then
                  call push(iLs, iR + 1)
                  call push(iRs, iROriginal)
                  iL = iLOriginal
                  exit loop_to_swap
                end if

                iL = iL + 1
              end do

              call swapping(xs(iL), xs(iR))
            end do loop_to_swap
          case default
            raise('Must not happen.')
          end select
        end do
      end do
    end subroutine sorting_quick<%= t %>

    function get_pivot<%= t %>(xs, isUniform) result(pivot)
      <%= t.declare %>:: pivot
      <%= t.declare %>, intent(in):: xs(:)
      Logical, intent(out):: isUniform
      <%= t.declare %>:: xsMin, xsMax
      Integer(kind = INT64):: iL, iR, nXs

      nXs = size(xs, dim = 1, kind = INT64)
      if(xs(1) <= xs(nXs))then
        xsMin = xs(1)
        xsMax = xs(nXs)
      else
        xsMin = xs(nXs)
        xsMax = xs(1)
      end if
      iL = 1 + 1
      iR = nXs - 1
      do while(iL <= iR)
        if(xs(iL) <= xs(iR))then
          if(xs(iL) < xsMin) xsMin = xs(iL)
          if(xs(iR) > xsMax) xsMax = xs(iR)
        else if(xs(iL) > xs(iR))then
          if(xs(iR) < xsMin) xsMin = xs(iR)
          if(xs(iL) > xsMax) xsMax = xs(iL)
        end if

        if(xsMin < xsMax) exit
        iL = iL + 1
        iR = iR - 1
      end do

      isUniform = (xsMax <= xsMin)
      if(isUniform)then
        pivot = -huge(pivot)
        return
      end if

      if(is_infinity(xsMax))then
        pivot = huge(xsMax)
      elseif(is_infinity(-xsMin))then
        pivot = -huge(xsMin)
      else
        pivot = (xsMin/2) + (xsMax/2)

        if(pivot >= xsMax .or. pivot < xsMin) pivot = xsMin ! I'm not sure whether the second condition could be true.
      end if
    end function get_pivot<%= t %>

    function sort_merge<%= t %>(xs) result(xsSorted)
      <%= t.declare %>, intent(in):: xs(:)
      <%= t.declare %>, allocatable:: xsSorted(:)

      xsSorted = xs
      call sorting_merge<%= t %>(xsSorted)
    end function sort_merge<%= t %>

    subroutine sorting_merge<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(:)

      raise_if(any(is_nan(xs)))
      call sorting_merge_substance<%= t %>(xs)
    end subroutine sorting_merge<%= t %>

    recursive subroutine sorting_merge_substance<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(:)
      <%= t.declare %>, allocatable:: xsL(:), xsR(:)
      Integer(kind = INT64):: nXs

      nXs = size(xs, dim = 1, kind = INT64)
      select case(nXs)
      case(:1)
        ! Nothing to do.
      case(2)
        call sorting_2(xs)
      case(3)
        call sorting_3(xs)
      case default
        xsL = xs(1:nXs/2)
        xsR = xs((nXs/2 + 1):nXs)
        call sorting_merge_substance(xsL)
        call sorting_merge_substance(xsR)
        call merge_sorted_lists(xsL, xsR, xs)
      end select
    end subroutine sorting_merge_substance<%= t %>

    ! Merge sorted 1-D array xs and ys into zs.
    subroutine merge_sorted_lists<%= t %>(xs, ys, zs)
      <%= t.declare %>, intent(in):: xs(:), ys(:)
      <%= t.declare %>, intent(out):: zs(:)
      Integer(kind = INT64):: iXs, nXs, iYs, nYs, iZs, nZs

      nXs = size(xs, dim = 1, kind = INT64)
      nYs = size(ys, dim = 1, kind = INT64)
      nZs = size(zs, dim = 1, kind = INT64)
      debug_assert(nXs >= 1)
      debug_assert(nYs >= 1)
      debug_assert(nZs >= 1)
      debug_assert(nXs + nYs == nZs)

      iXs = 1
      iYs = 1
      iZs = 1
      do while(iXs <= nXs .and. iYs <= nYs)
        debug_assert(iZs <= nZs)

        if(xs(iXs) <= ys(iYs))then
          zs(iZs) = xs(iXs)
          iXs = iXs + 1
        else
          zs(iZs) = ys(iYs)
          iYs = iYs + 1
        end if
        iZs = iZs + 1
      end do

      if(iXs <= nXs)then
        zs(iZs:nZs) = xs(iXs:nXs)
      else
        zs(iZs:nZs) = ys(iYs:nYs)
      end if
    end subroutine merge_sorted_lists<%= t %>

    pure subroutine sorting_3<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(1:3)

      if(xs(3) < xs(1)) call swapping(xs(1), xs(3))
      if(xs(3) < xs(2))then
        call swapping(xs(2), xs(3))
      else if(xs(2) < xs(1))then
        call swapping(xs(1), xs(2))
      end if
    end subroutine sorting_3<%= t %>

    pure subroutine sorting_2<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(1:2)

      if(xs(2) < xs(1)) call swapping(xs(1), xs(2))
    end subroutine sorting_2<%= t %>

    elemental subroutine swapping<%= t %>(a, b)
      <%= t.declare %>, intent(inout):: a, b
      <%= t.declare %>:: swap

      swap = b
      b = a
      a = swap
    end subroutine swapping<%= t %>
  <%- } -%>
end module lib_sort
