<%-
  require 'fort'

  INTEGERS = ::Fort::Type::Integer.multi_provide(dim: 0)
  REALS = ::Fort::Type::Real.multi_provide(dim: 0)
  TYPES = INTEGERS + REALS
-%>

#include "utils.h"
module lib_sort
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  USE_UTILS_H
  use lib_comparable, only: is_nan, is_infinity

  use lib_stack, only: push, pop
  use lib_stack, only: IntegerDim0KindINT64Stack

  implicit none

  private

  public:: sort_quick, sorting_quick

  <%- TYPES.each{|t| -%>
    interface sort_quick
      module procedure sort_quick<%= t %>
    end interface sort_quick

    interface sorting_quick
      module procedure sorting_quick<%= t %>
    end interface sorting_quick

    interface get_pivot
      module procedure get_pivot<%= t %>
    end interface get_pivot

    interface sorting_3
      module procedure sorting_3<%= t %>
    end interface sorting_3

    interface sorting_2
      module procedure sorting_2<%= t %>
    end interface sorting_2

    interface swapping
      module procedure swapping<%= t %>
    end interface swapping
  <%- } -%>

contains

  <%- TYPES.each{|t| -%>
    function sort_quick<%= t %>(xs) result(xsSorted)
      <%= t.declare %>, allocatable:: xsSorted(:)
      <%= t.declare %>, intent(in):: xs(:)

      xsSorted = xs
      call sorting_quick(xsSorted)
    end function sort_quick<%= t %>

    subroutine sorting_quick<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(:)
      <%= t.declare %>:: pivot
      type(IntegerDim0KindINT64Stack):: iLs, iRs
      Integer(kind = INT64):: iL, iR, iLOriginal, iROriginal
      Logical:: isUniform

      raise_if(any(is_nan(xs)))

      call push(iLs, 1_INT64)
      call push(iRs, size(xs, dim = 1, kind = INT64))

      do while(pop(iRs, iR))    ! Loop for all segments on the stacks.
        assert(pop(iLs, iL))

        iLOriginal = iL      ! Left most index of the current segment.
        do while(iLOriginal < iR) ! While current segment remains
          select case(iR - iL)
          case(-1, 0)
            exit
          case(1)
            call sorting_2(xs(iL:iR))
            exit
          case(2)
            call sorting_3(xs(iL:iR))
            exit
          case(3:)
            pivot = get_pivot(xs(iL:iR), isUniform)
            if(isUniform) exit

            iROriginal = iR  ! Right most index of the current segment
            loop_to_swap: do ! Within the segment
              do while(xs(iR) > pivot)
                iR = iR - 1
              end do
              do while(xs(iL) <= pivot)
                if(iL >= iR)then
                  call push(iLs, iR + 1)
                  call push(iRs, iROriginal)
                  iL = iLOriginal
                  exit loop_to_swap
                end if

                iL = iL + 1
              end do

              call swapping(xs(iL), xs(iR))
            end do loop_to_swap
          case default
            raise('Must not happen.')
          end select
        end do
      end do
    end subroutine sorting_quick<%= t %>

    function get_pivot<%= t %>(xs, isUniform) result(pivot)
      <%= t.declare %>:: pivot
      <%= t.declare %>, intent(in):: xs(:)
      Logical, intent(out):: isUniform
      <%= t.declare %>:: xsMin, xsMax
      Integer(kind = INT64):: iL, iR, nXs

      nXs = size(xs, dim = 1, kind = INT64)
      if(xs(1) <= xs(nXs))then
        xsMin = xs(1)
        xsMax = xs(nXs)
      else
        xsMin = xs(nXs)
        xsMax = xs(1)
      end if
      iL = 1 + 1
      iR = nXs - 1
      do while(iL <= iR)
        if(xs(iL) <= xs(iR))then
          if(xs(iL) < xsMin) xsMin = xs(iL)
          if(xs(iR) > xsMax) xsMax = xs(iR)
        else if(xs(iL) > xs(iR))then
          if(xs(iR) < xsMin) xsMin = xs(iR)
          if(xs(iL) > xsMax) xsMax = xs(iL)
        end if

        if(xsMin < xsMax) exit
        iL = iL + 1
        iR = iR - 1
      end do

      isUniform = (xsMax <= xsMin)
      if(isUniform)then
        pivot = -huge(pivot)
        return
      end if

      if(is_infinity(xsMax))then
        pivot = huge(xsMax)
      elseif(is_infinity(-xsMin))then
        pivot = -huge(xsMin)
      else
        pivot = (xsMin/2) + (xsMax/2)

        if(pivot >= xsMax .or. pivot < xsMin) pivot = xsMin ! I'm not sure whether the second condition could be true.
      end if
    end function get_pivot<%= t %>

    pure subroutine sorting_3<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(1:3)

      if(xs(3) < xs(1)) call swapping(xs(1), xs(3))
      if(xs(3) < xs(2))then
        call swapping(xs(2), xs(3))
      else if(xs(2) < xs(1))then
        call swapping(xs(1), xs(2))
      end if
    end subroutine sorting_3<%= t %>

    pure subroutine sorting_2<%= t %>(xs)
      <%= t.declare %>, intent(inout):: xs(1:2)

      if(xs(2) < xs(1)) call swapping(xs(1), xs(2))
    end subroutine sorting_2<%= t %>

    elemental subroutine swapping<%= t %>(a, b)
      <%= t.declare %>, intent(inout):: a, b
      <%= t.declare %>:: swap

      swap = b
      b = a
      a = swap
    end subroutine swapping<%= t %>
  <%- } -%>
end module lib_sort
