<%
  class Type
    attr_reader :type, :val

    def initialize(type, is_intrinsic = true)
      @type = if is_intrinsic
                type
              else
                "type(#{type})"
              end
      @val = '_' + type.gsub(/\W/, '_')
    end

    class ::String
      def to_type(is_intrinsic = true)
        Type.new(self, is_intrinsic)
      end
    end
  end

  def list(n, str = ', ', &block)
    (1..n).map(&block).join(str)
  end

  def parenthesis(n)
    buf = ([':']*n).join(", ")
    if n == 0 then buf else "(#{buf})" end
  end

  TYPES = [
    'integer',
    'integer(8)',
    'real',
    'double precision',
    'complex',
    'complex(kind(0.0d0))',
    'logical',
  ].map(&:to_type)

  DIM_MAX = 7
  DIM_RANGE = (1..DIM_MAX)

  NUM_DESC_MAX = 10
%>

! AUTHOR = 'Kasahara Amato'
module lib_io
  use, intrinsic:: iso_fortran_env, only: ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT
  use lib_character, only: TAB, s, str
  use lib_util, only: raise, check

  implicit none

  private
  public:: VERSION, ARRAY_DATA_FILE, ARRAY_META_FILE, ARRAY_VERSION_FILE, ARRAY_DESCRIPTION_FILE
  public:: TMP_DIR
  public:: SHELL_INTERFACE_FILE
  public:: new_unit
  public:: write_array, read_array
  public:: number_of_lines, number_of_columns, file_shape
  public:: mkdir_p
  public:: tempfile
  public:: close_tempfile
  public:: init_shell_interface_file
  public:: read_shell_interface_file

  integer, parameter:: VERSION = 1 ! Array file format's compatibility.
  integer, parameter:: NEW_UNIT_MIN = max(ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT, 0) + 1 ! 0 is decraled to handle a case where *_UNIT <= -1.
  integer, parameter:: NEW_UNIT_MAX = huge(0)
  character(len = *), parameter:: ARRAY_DATA_FILE = 'data.bin'
  character(len = *), parameter:: ARRAY_META_FILE = 'meta.nml'
  character(len = *), parameter:: ARRAY_VERSION_FILE = 'version.dat'
  character(len = *), parameter:: ARRAY_DESCRIPTION_FILE = 'description.txt'
  character(len = *), parameter:: TMP_DIR = 'tmp'
  character(len = *), parameter:: SHELL_INTERFACE_FILE = TMP_DIR // '/' // 'shell_interface.dat'

  interface new_unit
    <% ['integer', 'integer(8)'].map(&:to_type).each{|t| %>
      module procedure new_unit<%= t.val %>
    <% } %>
  end interface new_unit

  <% TYPES.each{|t| %>
    <% DIM_RANGE.each{|dim| %>
      interface write_array
        module procedure write_array<%= t.val %>_<%= dim %>
      end interface write_array

      interface read_array
        module procedure read_array<%= t.val %>_<%= dim %>
      end interface read_array

      interface read_array_v_1
        module procedure read_array_v_1<%= t.val %>_<%= dim %>
      end interface read_array_v_1
    <% } %>
  <% } %>

contains

  subroutine init_shell_interface_file()
    call mkdir_p(TMP_DIR)
    call execute_command_line("cat /dev/null > " // SHELL_INTERFACE_FILE)
  end subroutine init_shell_interface_file

  ! YAGNI: this can easily expand to val for r, R, i, I, z, Z, and l.
  subroutine read_shell_interface_file(val)
    character(len = *), intent(out):: val

    integer:: ioU

    call new_unit(ioU)
    open(ioU, file = SHELL_INTERFACE_FILE, status = 'old', action = 'read')
    read(ioU, *) val
    close(ioU)
  end subroutine read_shell_interface_file

  subroutine tempfile(ioU, file)
    integer, intent(out):: ioU
    character(len = *), intent(out):: file

    call init_shell_interface_file()
    ! tempfile name must be quoted since '/' mark is regarded to be end of record (same as namelist).
    call execute_command_line('echo \"$(tempfile)\" > ' // SHELL_INTERFACE_FILE)
    call read_shell_interface_file(file)
    call new_unit(ioU)
    open(ioU, file = s(file), status = 'old', action = 'readwrite')
  end subroutine tempfile

  subroutine close_tempfile(ioU)
    integer, intent(in):: ioU

    close(ioU, status = 'delete')
  end subroutine close_tempfile

  subroutine mkdir_p(path, exitStatus)
    character(len = *) path
    integer, intent(out), optional:: exitStatus
    integer:: exitStatus_
    call execute_command_line("mkdir -p " // s(path), exitstat = exitStatus_)

    if(present(exitStatus))then
      exitStatus = exitStatus_
    elseif(exitStatus_ /= 0)then
      call raise("Failed: mkdir -p ", s(path))
    end if
  end subroutine mkdir_p

  ! @desc Return a size 2 array which contains (/numberOfLines, numberOfColumns/) of the file fileName.
  function file_shape(fileName, numberOfHeaders) result(this)
    integer(8):: this(1:2)
    character(len = *), intent(in):: fileName
    integer, intent(in), optional:: numberOfHeaders

    integer:: numberOfHeaders_

    numberOfHeaders_ = 0
    if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

    this = (/number_of_lines(fileName) - numberOfHeaders_, number_of_columns(fileName, numberOfHeaders_)/)
  end function file_shape

  function number_of_lines(fileName) result(this)
    integer(8):: this
    character(len = *), intent(in):: fileName

    integer:: rU1, ios
    character:: dummy

    call new_unit(rU1)
    open(rU1, file = fileName, status = 'old', action = 'read')
    do this = 0, huge(this)
      read(rU1, *, iostat = ios) dummy
      if(ios /= 0) exit
    end do
    close(rU1)
  end function number_of_lines

  ! @desc Return number of columns at line (numberOfHeaders + 1) in file fileName.
  ! @desc The line is separated by space and tabs character.
  ! @desc Quoted string containing space/tab characteres is not considared.
  function number_of_columns(fileName, numberOfHeaders) result(this)
    integer(8):: this
    character(len = *), intent(in):: fileName
    integer, intent(in), optional:: numberOfHeaders

    enum, bind(c)
      enumerator:: SEEK_NORMAL_CHAR, SEEK_SPACE_OR_TAB
    end enum
    integer:: rU1, ios, i, mode
    character:: c

    integer:: numberOfHeaders_

    numberOfHeaders_ = 0
    if(present(numberOfHeaders)) numberOfHeaders_ = numberOfHeaders

    mode = SEEK_NORMAL_CHAR
    this = 0
    call new_unit(rU1)
    open(rU1, file = fileName, status = 'old', action = 'read')
    do i = 1, numberOfHeaders_
      read(rU1, *)
    end do
    do
      read(rU1, '(a1)', advance = 'no', iostat = ios) c
      if(ios /= 0 .or. c == new_line('_'))then
        exit
      else if(mode == SEEK_NORMAL_CHAR .and. c /= ' ' .and. c /= TAB)then
        this = this + 1
        mode = SEEK_SPACE_OR_TAB
        cycle
      else if(mode == SEEK_SPACE_OR_TAB .and. (c == ' ' .or. c == TAB))then
        mode = SEEK_NORMAL_CHAR
        cycle
      else
        call raise('Must not happen.')
      end if
    end do
    close(rU1)
  end function number_of_columns

  <% TYPES.each{|t| %>
    <% DIM_RANGE.each{|dim| %>
      subroutine write_array<%= t.val %>_<%= dim %>(arrayDir, array<%= list(NUM_DESC_MAX, ''){|i| ", desc#{i}"} %>)
        character(len = *), intent(in):: arrayDir
        <%= t.type %>, intent(in):: array<%= parenthesis(dim) %>
        <% if NUM_DESC_MAX >= 1 %>
          character(len = *), intent(in), optional:: <%= list(NUM_DESC_MAX){|i| "desc#{i}"} %>
        <% end %>

        character(len = *), parameter:: DATA_TYPE_FOR_SELF = '<%= t.type %>'
        integer, parameter:: DIM_FOR_SELF = <%= dim %>

        character(len = len(DATA_TYPE_FOR_SELF)) dataType
        integer:: dim
        integer:: sizes(1:DIM_FOR_SELF)
        integer:: wU1
        integer:: i

        namelist /array_meta/ dataType, dim, sizes

        call mkdir_p(s(arrayDir))

        call new_unit(wU1)
        open(unit = wU1, file = s(arrayDir) // '/' // ARRAY_VERSION_FILE, status = 'replace', action = 'write')
        write(wU1, *) VERSION
        close(wU1)

        call new_unit(wU1)
        open(unit = wU1, file = s(arrayDir) // '/' // ARRAY_DATA_FILE, status = 'replace', action = 'write', form = 'unformatted')
        write(wU1) array
        close(wU1)

        dataType = DATA_TYPE_FOR_SELF
        dim = DIM_FOR_SELF
        forall(i = 1:dim) sizes(i) = size(array, i)
        call new_unit(wU1)
        open(unit = wU1, file = s(arrayDir) // '/' // ARRAY_META_FILE, status = 'replace', action = 'write')
        write(wU1, nml = array_meta)
        close(wU1)

        open(unit = wU1, file = s(arrayDir) // '/' // ARRAY_DESCRIPTION_FILE, status = 'replace', action = 'write')
        <% (1..NUM_DESC_MAX).each{|i| %>
          if(present(desc<%= i %>)) write(wU1, *) desc<%= i %>
        <% } %>
        close(wU1)
      end subroutine write_array<%= t.val %>_<%= dim %>

      subroutine read_array<%= t.val %>_<%= dim %>(arrayDir, array)
        character(len = *), intent(in):: arrayDir
        <%= t.type %>, intent(out), allocatable:: array<%= parenthesis(dim) %>

        integer:: rU1, libIoVersion

        call new_unit(rU1)
        open(unit = rU1, file = s(arrayDir) // '/' // ARRAY_VERSION_FILE, status = 'old', action = 'read')
        read(rU1, *) libIoVersion
        close(rU1)

        select case(libIoVersion)
        case(1)
          call read_array_v_1(arrayDir, array)
        case default
          call raise("Unsupported version: ", libIoVersion)
        end select
      end subroutine read_array<%= t.val %>_<%= dim %>

      subroutine read_array_v_1<%= t.val %>_<%= dim %>(arrayDir, array)
        character(len = *), intent(in):: arrayDir
        <%= t.type %>, intent(out), allocatable:: array<%= parenthesis(dim) %>

        character(len = *), parameter:: DATA_TYPE_FOR_SELF = '<%= t.type %>'
        integer, parameter:: DIM_FOR_SELF = <%= dim %>
        character(len = <%= TYPES.map{|_t| _t.type.size}.max %>):: dataType
        integer:: dim
        integer:: sizes(1:DIM_FOR_SELF)
        integer:: rU1
        namelist /array_meta/ dataType, dim, sizes

        call new_unit(rU1)
        open(unit = rU1, file = s(arrayDir) // '/' // ARRAY_META_FILE, status = 'old', action = 'read')
        read(rU1, nml = array_meta)

        call check(s(dataType) == DATA_TYPE_FOR_SELF, 'Data type mismatch. Expected ' // DATA_TYPE_FOR_SELF // ' but type of ' // s(arrayDir) // ' is ', s(dataType))
        call check(dim == DIM_FOR_SELF, 'Dimension mismatch. Expected' // str(DIM_FOR_SELF) // ' but dimension of ' // s(arrayDir) // ' is ' // str(dim))

        close(rU1)

        allocate(array(<%= list(dim){|i| "1:sizes(#{i})"} %>))

        call new_unit(rU1)
        open(unit = rU1, file = s(arrayDir) // '/' // ARRAY_DATA_FILE, status = 'old', action = 'read', form = 'unformatted')
        read(rU1) array
      end subroutine read_array_v_1<%= t.val %>_<%= dim %>
    <% } %>
  <% } %>


  <% ['integer', 'integer(8)'].map(&:to_type).each{|t| %>
    subroutine new_unit<%= t.val %>(n)
      <%= t.type %>, intent(out):: n
      <%= t.type %>:: i
      logical:: isOpened

      do i = NEW_UNIT_MIN, NEW_UNIT_MAX
        inquire(unit = i, opened = isOpened)
        if(.not.(isOpened))then
          n = i
          return
        end if
      end do

      call raise("No available unit number exist between: ",  (/NEW_UNIT_MIN, NEW_UNIT_MAX/))
    end subroutine new_unit<%= t.val %>
  <% } %>
end module lib_io
