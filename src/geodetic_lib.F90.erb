<%-
  require 'fort'

  REALS = ::Fort::Type::Real.multi_provide(dim: 0)
-%>

# include "utils.h"
module geodetic_lib
   USE_UTILS_H
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>

   use, non_intrinsic:: constant_lib, only: deg_from_rad, rad_from_deg
   <%- REALS.each{|t| -%>
      use, non_intrinsic:: constant_lib, only: PI<%= t %>
   <%- } -%>

   implicit none

   private
   public:: ecef_from_wgs84, wgs84_from_ecef

   ! WGS84
   ! http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf (google by nga wgs84)
   Real(kind = REAL64), parameter, public:: WGS84_A         = 6378137.0_REAL64                ! semi-major axis (m)
   Real(kind = REAL64), parameter, public:: WGS84_F         = 1/298.257223563_REAL64          ! flattening
   Real(kind = REAL64), parameter, public:: WGS84_W         = 7292115.0_REAL64*10**(-11)      ! angular velocity of the earth (rad/s)
   Real(kind = REAL64), parameter, public:: WGS84_GM        = 3986004.418_REAL64*10**8        ! earth's gravitational constant (mass of earth's atmosphere included) (m**3/s**2)
   Real(kind = REAL64), parameter, public:: WGS84_GM_PRIME  = 3986000.9_REAL64*10**8          ! gravitational constant (mass of earth's atmosphere not included) (m**3/s**2) 1 sigma is +/- 0.1*10**8 (m**3/s**2)
   Real(kind = REAL32), parameter, public:: WGS84_GM_A      = 3.5_REAL32*10**8                ! gm of the earth's atmosphere (m**3/s**2) 1 sigma is +/- 0.1*10**8 (m**3/s**2)
   Real(kind = REAL64), parameter, public:: WGS84_B         = 6356752.3142_REAL64             ! semi-minor axis (m)
   Real(kind = REAL64), parameter, public:: WGS84_E         = 8.1819190842622_REAL64*10**(-2) ! first eccentricity: sqrt(1 - b**2/a**2)
   Real(kind = REAL64), parameter, public:: WGS84_E_2       = 6.69437999014_REAL64*10**(-3)   ! first eccentricity squared
   Real(kind = REAL64), parameter, public:: WGS84_E_PRIME   = 8.2094437949696_REAL64*10**(-2) ! second eccentricity: sqrt(a**2/b**2 - 1)
   Real(kind = REAL64), parameter, public:: WGS84_E_PRIME_2 = 6.73949674228_REAL64*10**(-3)   ! second eccentricity squared

   <%- REALS.each{|t| -%>
     interface ecef_from_wgs84
        module procedure ecef_from_wgs84<%= t %>
        module procedure ecef_from_wgs84_array<%= t %>
     end interface ecef_from_wgs84

     interface ecef_from_wgs84_rad
        module procedure ecef_from_wgs84_rad<%= t %>
     end interface ecef_from_wgs84_rad

     interface wgs84_from_ecef
        module procedure wgs84_from_ecef<%= t %>
        module procedure wgs84_from_ecef_array<%= t %>
     end interface wgs84_from_ecef

     interface wgs84_rad_from_ecef
        module procedure wgs84_rad_from_ecef<%= t %>
     end interface wgs84_rad_from_ecef

     interface normalize_lon
        module procedure normalize_lon<%= t %>
     end interface normalize_lon

     interface normalize_lon_rad
        module procedure normalize_lon_rad<%= t %>
     end interface normalize_lon_rad

     interface get_l
        module procedure get_l<%= t %>
     end interface get_l

     interface get_z
        module procedure get_z<%= t %>
     end interface get_z
   <%- } -%>

contains

   <%- REALS.each{|t| -%>
      function ecef_from_wgs84_array<%= t %>(lonLatH) result(xyz)
         <%= t.declare %>, intent(in):: lonLatH(1:3) ! (deg, deg, m)
         <%= t.declare %>:: xyz(1:3) ! (m, m, m)

         xyz = ecef_from_wgs84(lonLatH(1), lonLatH(2), lonLatH(3))
      end function ecef_from_wgs84_array<%= t %>

      function ecef_from_wgs84<%= t %>(lon, lat, h) result(xyz)
         <%= t.declare %>, intent(in):: lat ! (deg)
         <%= t.declare %>, intent(in):: lon ! (deg)
         <%= t.declare %>, intent(in):: h ! (m)
         <%= t.declare %>:: xyz(1:3) ! (m, m, m)

         ASSERT(-90 <= lat .and. lat <= 90)
         xyz = ecef_from_wgs84_rad(rad_from_deg(normalize_lon(lon)), rad_from_deg(lat), h)
      end function ecef_from_wgs84<%= t %>

      function ecef_from_wgs84_rad<%= t %>(lon, lat, h) result(xyz)
         <%= t.declare %>, parameter:: HALF_PI = PI<%= t %>/2
         <%= t.declare %>, intent(in):: lat ! (rad)
         <%= t.declare %>, intent(in):: lon ! (rad)
         <%= t.declare %>, intent(in):: h ! (m)
         <%= t.declare %>:: xyz(1:3) ! (m, m, m)
         <%= t.declare %>:: l

         ASSERT(-HALF_PI <= lat .and. lat <= HALF_PI)

         l = get_l(lat)
         xyz(1) = (l + h)*cos(lat)*cos(lon)
         xyz(2) = (l + h)*cos(lat)*sin(lon)
         xyz(3) = ((1 - WGS84_E_2)*l + h)*sin(lat)
      end function ecef_from_wgs84_rad<%= t %>

      function wgs84_from_ecef_array<%= t %>(xyz) result(lonLatH)
         <%= t.declare %>, intent(in):: xyz(1:3) ! (m, m, m)
         <%= t.declare %>:: lonLatH(1:3)
         
         lonLatH = wgs84_from_ecef(xyz(1), xyz(2), xyz(3))
      end function wgs84_from_ecef_array<%= t %>

      function wgs84_from_ecef<%= t %>(x, y, z) result(lonLatH)
         <%= t.declare %>, intent(in):: x ! (m)
         <%= t.declare %>, intent(in):: y ! (m)
         <%= t.declare %>, intent(in):: z ! (m)
         <%= t.declare %>:: lonLatH(1:3) ! (deg, deg, m)
         <%= t.declare %>:: lonLatHRad(1:3)

         lonLatHRad = wgs84_rad_from_ecef(x, y, z)
         lonLatH(1:2) = deg_from_rad(lonLatHRad(1:2))
         lonLatH(3) = lonLatHRad(3)
      end function wgs84_from_ecef<%= t %>

      function wgs84_rad_from_ecef<%= t %>(x, y, z) result(lonLatH)
         <%= t.declare %>, intent(in):: x ! (m)
         <%= t.declare %>, intent(in):: y ! (m)
         <%= t.declare %>, intent(in):: z ! (m)
         <%= t.declare %>:: lonLatH(1:3) ! (rad, rad, m)
         <%= t.declare %>:: lon, lat, xy, dLat, lat0, lat0Min, zDiff, zDiffMin
         Real(kind = kind(lon)), parameter:: PI = PI<%= t %>
         Integer, parameter:: scale = 2**3
         Integer:: iLat

         lon = atan2(y, x)
         xy = hypot(x, y)

         ! Grid search for the best lat.
         lat0Min = 0
         dLat = PI/2/scale
         zDiffMin = huge(zDiffMin)
         do while(dLat > tiny(dLat) .and. dLat >= lat0Min*epsilon(lat0Min)/2)
            lat0 = lat0Min
            do iLat = -scale + 1, scale - 1
               lat = lat0 + iLat*dLat
               zDiff = abs(z - get_z(lat, xy))
               if(zDiff < zDiffMin)then
                  lat0Min = lat
                  zDiffMin = zDiff
               end if
            end do
            dLat = dLat/scale ! Increase precision
         end do

         lonLatH(1) = lon
         lonLatH(2) = lat
         lonLatH(3) = x/cos(lat) - get_l(lat)
      end function wgs84_rad_from_ecef<%= t %>

      function get_l<%= t %>(lat) result(ret)
         <%= t.declare %>, intent(in):: lat ! (deg)
         <%= t.declare %>:: ret

         ret = WGS84_A/sqrt(1 - (WGS84_E_2*sin(lat))**2)
      end function get_l<%= t %>

      function get_z<%= t %>(lat, xy) result(ret)
         <%= t.declare %>, intent(in):: lat ! (deg)
         <%= t.declare %>, intent(in):: xy ! (m)
         <%= t.declare %>:: ret
         <%= t.declare %>:: l

         l = get_l(lat)
         ret = ((1 - WGS84_E_2)*l + xy/cos(lat) - l)*sin(lat)
      end function get_z<%= t %>

      elemental function normalize_lon<%= t %>(lon) result(ret)
         <%= t.declare %>, intent(in):: lon ! (deg)
         <%= t.declare %>:: ret ! (deg)

         if(lon < -180 .or. 180 < lon)then
            ret = lon - floor(lon/180)*180
         else
            ret = lon
         end if
      end function normalize_lon<%= t %>

      elemental function normalize_lon_rad<%= t %>(lon) result(ret)
         <%= t.declare %>, parameter:: HALF_PI = PI<%= t %>/2
         <%= t.declare %>, intent(in):: lon ! (rad)
         <%= t.declare %>:: ret ! (rad)

         if(lon < HALF_PI .or. HALF_PI < lon)then
            ret = lon - floor(lon/HALF_PI)*HALF_PI
         else
            ret = lon
         end if
      end function normalize_lon_rad<%= t %>
   <%- } -%>
end module geodetic_lib
