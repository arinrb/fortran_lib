<%
  require 'fort'

  INT_KINDS = [8, 16, 32, 64]
  INT_KIND_PAIRS = INT_KINDS.product(INT_KINDS)
  REAL_KINDS = [32, 64,128]
  REAL_KIND_PAIRS = REAL_KINDS.product(REAL_KINDS)

  INTEGER_PAIRS = INT_KIND_PAIRS.map{|kinds| kinds.map{|kind| ::Fort::Type::IntegerType.new(0, kind)}}
  REAL_PAIRS = REAL_KIND_PAIRS.map{|kinds| kinds.map{|kind| ::Fort::Type::RealType.new(0, kind)}}
  COMPLEX_PAIRS = REAL_KIND_PAIRS.map{|kinds| kinds.map{|kind| ::Fort::Type::ComplexType.new(0, kind)}}
  LOGICAL_PAIRS = [[::Fort::Type::LogicalType.new(0), ::Fort::Type::LogicalType.new(0)]]
  CHARACTER_PAIRS = [[::Fort::Type::CharacterType.new(0, '*'), ::Fort::Type::CharacterType.new(0, '*')]]
%>

module lib_comparable
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>

  implicit none

  private
  public:: equivalent

  interface equivalent
    <%- (INTEGER_PAIRS + REAL_PAIRS + COMPLEX_PAIRS + LOGICAL_PAIRS + CHARACTER_PAIRS).each{|t1, t2| -%>
      module procedure equivalent<%= t1 %><%= t2 %>
    <%- } -%>
  end interface equivalent

contains


  <%- REAL_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b, delta) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b
      real(max(kind(a), kind(b))), intent(in), optional:: delta

      real(kind(delta)):: delta_, deltaRelative, deltaAbsolute
      real(min(kind(a), kind(b))):: lowerPrecision

      if(present(delta))then
        delta_ = delta*max(abs(a), abs(b))
      else
        deltaRelative = max(epsilon(a)*abs(a), epsilon(b)*abs(b))
        deltaAbsolute = epsilon(lowerPrecision)*tiny(lowerPrecision)
        delta_ = max(deltaRelative, deltaAbsolute)
      end if

      this = (abs(a - b) <= 2*delta_)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- COMPLEX_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b, delta) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b
      real(max(kind(a), kind(b))), intent(in), optional:: delta

      if(present(delta))then
        this = equivalent(real(a), real(b), delta) .and. equivalent(aimag(a), aimag(b), delta)
      else
        this = equivalent(real(a), real(b)) .and. equivalent(aimag(a), aimag(b))
      end if
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- INTEGER_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = (a == b)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- LOGICAL_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = a .eqv. b
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- CHARACTER_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = (a == b)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>
end module lib_comparable
