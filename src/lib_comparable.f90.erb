<%
  require 'fort'

  integers = ::Fort::Type::Integer.multi_provide(dim: 0)
  INTEGER_PAIRS = integers.product(integers)

  reals = ::Fort::Type::Real.multi_provide(dim: 0)
  REAL_PAIRS = reals.product(reals)

  complexes = ::Fort::Type::Complex.multi_provide(dim: 0)
  COMPLEX_PAIRS = complexes.product(complexes)

  logicals = ::Fort::Type::Logical.multi_provide(dim: 0)
  LOGICAL_PAIRS = logicals.product(logicals)

  characters = ::Fort::Type::Character.multi_provide(dim: 0)
  CHARACTER_PAIRS = characters.product(characters)
%>

module lib_comparable
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>

  implicit none

  private
  public:: equivalent

  interface equivalent
    <%- (INTEGER_PAIRS + REAL_PAIRS + COMPLEX_PAIRS + LOGICAL_PAIRS + CHARACTER_PAIRS).each{|t1, t2| -%>
      module procedure equivalent<%= t1 %><%= t2 %>
    <%- } -%>
  end interface equivalent

contains

  <%- REAL_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b, delta) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b
      real(max(kind(a), kind(b))), intent(in), optional:: delta

      real(kind(delta)):: delta_, deltaRelative, deltaAbsolute
      real(min(kind(a), kind(b))):: lowerPrecision

      if(present(delta))then
        delta_ = delta*max(abs(a), abs(b))
      else
        deltaRelative = max(epsilon(a)*abs(a), epsilon(b)*abs(b))
        deltaAbsolute = epsilon(lowerPrecision)*tiny(lowerPrecision)
        delta_ = max(deltaRelative, deltaAbsolute)
      end if

      this = (abs(a - b) <= 2*delta_)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- COMPLEX_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b, delta) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b
      real(max(kind(a), kind(b))), intent(in), optional:: delta

      if(present(delta))then
        this = equivalent(real(a), real(b), delta) .and. equivalent(aimag(a), aimag(b), delta)
      else
        this = equivalent(real(a), real(b)) .and. equivalent(aimag(a), aimag(b))
      end if
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- INTEGER_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = (a == b)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- LOGICAL_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = a .eqv. b
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>

  <%- CHARACTER_PAIRS.each{|t1, t2| -%>
    elemental function equivalent<%= t1 %><%= t2 %>(a, b) result(this)
      logical:: this
      <%= t1.declare %>, intent(in):: a
      <%= t2.declare %>, intent(in):: b

      this = (a == b)
    end function equivalent<%= t1 %><%= t2 %>
  <%- } -%>
end module lib_comparable
