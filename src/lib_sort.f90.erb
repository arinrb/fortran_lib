<%-
  require 'fort'

  INTEGERS = ::Fort::Type::Integer.multi_provide(dim: 1)
  REALS = ::Fort::Type::Real.multi_provide(dim: 1)
  TYPES = INTEGERS + REALS
-%>

#include "utils.h"
module lib_sort
  <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
  USE_UTILS_H
  use lib_comparable, only: is_nan

  implicit none

  private

  public:: qsort

  <%- TYPES.each{|t| -%>
    interface qsort
      module procedure qsort<%= t %>
    end interface qsort
  <%- } -%>

  <%- INTEGERS.each{|t| -%>
    interface div_floor
      module procedure div_floor<%= t %>
    end interface div_floor

    interface intermediate_floor_avoid_overflow
      module procedure intermediate_floor_avoid_overflow<%= t %>
    end interface intermediate_floor_avoid_overflow
  <%- } -%>

contains

  <%- INTEGERS.each{|t| -%>
    recursive function qsort<%= t %>(a) result(this)
      <%= t.declare %>, allocatable:: this
      <%= t.declare %>, intent(in):: a
      <%= t.type %>(kind = <%= t.kind %>):: aMin, aMax, pib

      if(size(a) <= 1)then
        this = a
        return
      end if

      aMin = minval(a)
      aMax = maxval(a)
      if(aMax <= aMin)then
        this = a
        return
      end if

      pib = intermediate_floor_avoid_overflow(aMin, aMax)
      this = [qsort(pack(a, a <= pib)), qsort(pack(a, a > pib))]
    end function qsort<%= t %>
    
    ! this: Floor of m/n.
    function div_floor<%= t %>(m, n) result(this)
      <%= t.type %>(kind = <%= t.kind %>):: this
      <%= t.type %>(kind = <%= t.kind %>), intent(in):: m, n

      this = m/n
      if(mod(m, n) < 0) this = this - 1_<%= t.kind %>
    end function div_floor<%= t %>
    
    ! this: Floor of intermediate of m and n without suffering overflow.
    function intermediate_floor_avoid_overflow<%= t %>(m, n) result(this)
      <%= t.type %>(kind = <%= t.kind %>):: this
      <%= t.type %>(kind = <%= t.kind %>), intent(in):: m, n

      this = div_floor(m, 2_<%= t.kind %>) + div_floor(n, 2_<%= t.kind %>)
      if((mod(m, 2) == 1 .and. mod(n, 2) == 1) .or. (mod(m, 2) == -1 .and. mod(n, 2) == -1)) this = this + 1_<%= t.kind %>
    end function intermediate_floor_avoid_overflow<%= t %>
  <%- } -%>

  <%- REALS.each{|t| -%>
    recursive function qsort<%= t %>(a) result(this)
      <%= t.declare %>, intent(in):: a
      <%= t.declare %>, allocatable:: this

      <%= t.type %>(kind = <%= t.kind %>):: aMin, aMax, pib
      Integer:: maxlocA(1:1), minlocA(1:1)

      raise_if(any(is_nan(a)))

      if(size(a) <= 1)then        ! Anchor case.
        this = a
        return
      end if

      aMin = minval(a)
      aMax = maxval(a)
      if(aMax <= aMin)then ! Quick return if possible: aMin equal aMax means all values in a are same.
        this = a
        return
      end if

      ! Infinity case.
      ! These case is separately handled since Inf - Inf = NaN although pib should not be NaN.
      if(aMin < -huge(aMin))then  ! -Inf
        minlocA = minloc(a)
        this = [aMin, qsort([a(1:minlocA(1) - 1), a(minlocA(1) + 1:size(a))])]
        return
      end if

      if(huge(aMax) < aMax)then   ! +Inf
        maxlocA = maxloc(a)
        this = [qsort([a(1:maxlocA(1) - 1), a(maxlocA(1) + 1:size(a))]), aMax]
        return
      end if


      pib = aMin/2 + aMax/2       ! Avoid overflow.
      this = [qsort(pack(a, a <= pib)), qsort(pack(a, a > pib))]
    end function qsort<%= t %>
  <%- } -%>
end module lib_sort
